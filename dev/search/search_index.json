{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Nevermined Payments Python SDK","text":"<p>The Nevermined Payments Python SDK provides a complete solution for integrating AI agent monetization and access control into your applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Payment Plans: Create and manage credits-based and time-based payment plans</li> <li>AI Agents: Register and monetize AI agents with flexible pricing models</li> <li>X402 Protocol: Industry-standard payment verification and settlement</li> <li>MCP Integration: Build monetized MCP (Model Context Protocol) servers</li> <li>A2A Protocol: Agent-to-Agent communication with payment support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from payments_py import Payments, PaymentOptions\n\n# Initialize the SDK\npayments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=\"your-nvm-api-key\",\n        environment=\"sandbox\"\n    )\n)\n\n# Create a payment plan\nfrom payments_py.common.types import PlanMetadata\nfrom payments_py.plans import get_erc20_price_config, get_fixed_credits_config\n\nplan_metadata = PlanMetadata(name=\"Basic Plan\", description=\"100 credits plan\")\nprice_config = get_erc20_price_config(20, ERC20_TOKEN_ADDRESS, builder_address)\ncredits_config = get_fixed_credits_config(100)\n\nresult = payments.plans.register_credits_plan(plan_metadata, price_config, credits_config)\nprint(f\"Plan created: {result['planId']}\")\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#api-reference","title":"API Reference","text":"<p>Step-by-step guides for using the SDK:</p> <ol> <li>Installation - How to install the library</li> <li>Initializing the Library - Configuration and setup</li> <li>Payment Plans - Create and manage payment plans</li> <li>Agents - Register and manage AI agents</li> <li>Publishing Static Resources - Publish files and datasets</li> <li>Payments and Balance - Order plans and check balances</li> <li>Querying an Agent - Get access tokens and make requests</li> <li>Request Validation - Validate incoming requests</li> <li>MCP Integration - Build MCP servers with payments</li> <li>A2A Integration - Agent-to-Agent protocol integration</li> <li>x402 Protocol - Payment permissions and settlement</li> </ol>"},{"location":"#reference","title":"Reference","text":"<p>Detailed API documentation:</p> <ul> <li>Payments Class - Main SDK class reference</li> <li>Data Models - Type definitions and models</li> <li>Environments - Environment configuration</li> </ul>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Repository</li> <li>Nevermined Documentation</li> <li>Nevermined App</li> </ul>"},{"location":"api/01-installation/","title":"Installation","text":"<p>This guide covers how to install the Nevermined Payments Python SDK.</p>"},{"location":"api/01-installation/#overview","title":"Overview","text":"<p>The Nevermined Payments Python SDK (<code>payments-py</code>) is a Python library that provides tools for integrating AI agent monetization and access control into your applications. It supports:</p> <ul> <li>Payment plans (credits-based and time-based)</li> <li>AI agent registration and management</li> <li>X402 payment protocol</li> <li>MCP (Model Context Protocol) integration</li> <li>A2A (Agent-to-Agent) protocol support</li> </ul>"},{"location":"api/01-installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing the SDK, ensure you have:</p> <ul> <li>Python 3.10 or higher - The SDK requires Python 3.10+</li> <li>pip or Poetry - Package manager for installation</li> <li>Nevermined API Key - Obtain from the Nevermined App</li> </ul>"},{"location":"api/01-installation/#installation-steps","title":"Installation Steps","text":""},{"location":"api/01-installation/#using-pip","title":"Using pip","text":"<pre><code>pip install payments-py\n</code></pre>"},{"location":"api/01-installation/#using-poetry","title":"Using Poetry","text":"<pre><code>poetry add payments-py\n</code></pre>"},{"location":"api/01-installation/#with-optional-dependencies","title":"With Optional Dependencies","text":"<p>For FastAPI/x402 middleware support:</p> <pre><code># Using pip\npip install payments-py[fastapi]\n\n# Using Poetry\npoetry add payments-py -E fastapi\n</code></pre>"},{"location":"api/01-installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify the SDK is working:</p> <pre><code>from payments_py import Payments, PaymentOptions\n\n# Check version\nimport payments_py\nprint(f\"payments-py installed successfully\")\n</code></pre>"},{"location":"api/01-installation/#environment-setup","title":"Environment Setup","text":"<p>Create a <code>.env</code> file or set environment variables:</p> <pre><code># Required\nNVM_API_KEY=nvm:your-api-key-here\n\n# Optional (for custom environments)\nNVM_BACKEND_URL=https://api.sandbox.nevermined.app\nNVM_PROXY_URL=https://proxy.sandbox.nevermined.app\n</code></pre>"},{"location":"api/01-installation/#next-steps","title":"Next Steps","text":"<p>Once installed, proceed to Initializing the Library to configure the SDK.</p>"},{"location":"api/02-initializing-the-library/","title":"Initializing the Library","text":"<p>This guide explains how to import, configure, and initialize the Nevermined Payments Python SDK.</p>"},{"location":"api/02-initializing-the-library/#get-the-nvm-api-key","title":"Get the NVM API Key","text":"<p>Before using the SDK, you need a Nevermined API Key:</p> <ol> <li>Go to the Nevermined App</li> <li>Sign in or create an account</li> <li>Navigate to Settings &gt; API Keys</li> <li>Generate a new API key</li> <li>Copy the key (format: <code>nvm:xxxxxxxx...</code>)</li> </ol> <p>Keep your API key secure</p> <p>Never commit your API key to version control. Use environment variables or a secrets manager.</p>"},{"location":"api/02-initializing-the-library/#import-and-initialize","title":"Import and Initialize","text":""},{"location":"api/02-initializing-the-library/#basic-initialization","title":"Basic Initialization","text":"<pre><code>from payments_py import Payments, PaymentOptions\n\n# Initialize with API key and environment\npayments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=\"nvm:your-api-key-here\",\n        environment=\"sandbox\"\n    )\n)\n\n# Verify initialization\nprint(f\"Connected to: {payments.environment.backend}\")\nprint(f\"Account: {payments.account_address}\")\n</code></pre>"},{"location":"api/02-initializing-the-library/#using-environment-variables","title":"Using Environment Variables","text":"<pre><code>import os\nfrom payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=os.getenv(\"NVM_API_KEY\"),\n        environment=os.getenv(\"NVM_ENVIRONMENT\", \"sandbox\")\n    )\n)\n</code></pre>"},{"location":"api/02-initializing-the-library/#configuration-options","title":"Configuration Options","text":"<p>The <code>PaymentOptions</code> class accepts the following parameters:</p> Parameter Type Required Description <code>nvm_api_key</code> <code>str</code> Yes Your Nevermined API key <code>environment</code> <code>str</code> Yes Environment name (see below) <code>app_id</code> <code>str</code> No Application identifier <code>version</code> <code>str</code> No Application version <code>headers</code> <code>dict</code> No Additional HTTP headers <code>return_url</code> <code>str</code> No Return URL (browser mode only) <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=\"nvm:your-api-key\",\n        environment=\"sandbox\",\n        app_id=\"my-app\",\n        version=\"1.0.0\",\n        headers={\"X-Custom-Header\": \"value\"}\n    )\n)\n</code></pre>"},{"location":"api/02-initializing-the-library/#environments","title":"Environments","text":""},{"location":"api/02-initializing-the-library/#sandbox-environment-testing","title":"Sandbox Environment (Testing)","text":"<p>Use <code>sandbox</code> for development and testing:</p> <pre><code>payments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=\"nvm:your-api-key\",\n        environment=\"sandbox\"\n    )\n)\n</code></pre> <ul> <li>Backend: <code>https://api.sandbox.nevermined.app</code></li> <li>Proxy: <code>https://proxy.sandbox.nevermined.app</code></li> <li>Uses test tokens and test networks</li> </ul>"},{"location":"api/02-initializing-the-library/#live-environment-production","title":"Live Environment (Production)","text":"<p>Use <code>live</code> for production:</p> <pre><code>payments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=\"nvm:your-api-key\",\n        environment=\"live\"\n    )\n)\n</code></pre> <ul> <li>Backend: <code>https://api.live.nevermined.app</code></li> <li>Proxy: <code>https://proxy.live.nevermined.app</code></li> <li>Uses real tokens and mainnet networks</li> </ul>"},{"location":"api/02-initializing-the-library/#custom-environment","title":"Custom Environment","text":"<p>For self-hosted or development setups:</p> <pre><code>import os\n\n# Set environment variables first\nos.environ[\"NVM_BACKEND_URL\"] = \"http://localhost:3001\"\nos.environ[\"NVM_PROXY_URL\"] = \"http://localhost:443\"\n\npayments = Payments.get_instance(\n    PaymentOptions(\n        nvm_api_key=\"nvm:your-api-key\",\n        environment=\"custom\"\n    )\n)\n</code></pre>"},{"location":"api/02-initializing-the-library/#available-environments","title":"Available Environments","text":"Environment Description <code>sandbox</code> Production sandbox (testing) <code>live</code> Production mainnet <code>custom</code> Custom URLs via environment variables"},{"location":"api/02-initializing-the-library/#accessing-sub-apis","title":"Accessing Sub-APIs","text":"<p>The initialized <code>Payments</code> object provides access to specialized APIs:</p> <pre><code># Plans API - manage payment plans\npayments.plans.register_credits_plan(...)\npayments.plans.get_plan(plan_id)\npayments.plans.get_plan_balance(plan_id)\n\n# Agents API - manage AI agents\npayments.agents.register_agent(...)\npayments.agents.get_agent(agent_id)\n\n# Facilitator API - x402 verification/settlement\npayments.facilitator.verify_permissions(...)\npayments.facilitator.settle_permissions(...)\n\n# X402 Token API - generate access tokens\npayments.x402.get_x402_access_token(plan_id, agent_id)\n\n# MCP Integration\npayments.mcp.register_tool(...)\nawait payments.mcp.start(config)\n\n# A2A Integration\npayments.a2a[\"start\"](agent_card=card, executor=executor)\n</code></pre>"},{"location":"api/02-initializing-the-library/#error-handling","title":"Error Handling","text":"<p>The SDK raises <code>PaymentsError</code> for API errors:</p> <pre><code>from payments_py.common.payments_error import PaymentsError\n\ntry:\n    result = payments.plans.get_plan(\"invalid-id\")\nexcept PaymentsError as e:\n    print(f\"Error: {e.message}\")\n    print(f\"Code: {e.code}\")\n</code></pre>"},{"location":"api/02-initializing-the-library/#next-steps","title":"Next Steps","text":"<p>Now that you have initialized the SDK, proceed to:</p> <ul> <li>Payment Plans - Create payment plans</li> <li>Agents - Register AI agents</li> </ul>"},{"location":"api/03-payment-plans/","title":"Payment Plans","text":"<p>This guide covers how to create and manage payment plans using the Nevermined Payments Python SDK.</p>"},{"location":"api/03-payment-plans/#overview","title":"Overview","text":"<p>Payment Plans define how users pay to access your AI agents and services. Nevermined supports two types of plans:</p> <ul> <li>Credits Plans: Users purchase a fixed number of credits that are consumed with each request</li> <li>Time Plans: Users purchase access for a specific duration (e.g., 1 day, 1 month)</li> </ul>"},{"location":"api/03-payment-plans/#plans-api","title":"Plans API","text":"<p>Access the Plans API through <code>payments.plans</code>:</p> <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\n# Access plans API\nplans_api = payments.plans\n</code></pre>"},{"location":"api/03-payment-plans/#types-of-payment-plans","title":"Types of Payment Plans","text":""},{"location":"api/03-payment-plans/#credits-plans","title":"Credits Plans","text":"<p>Credits plans grant users a fixed number of credits. Each agent request consumes credits according to the plan configuration.</p> <pre><code>from payments_py.common.types import PlanMetadata\nfrom payments_py.plans import get_erc20_price_config, get_fixed_credits_config\n\n# Plan metadata\nplan_metadata = PlanMetadata(\n    name=\"Basic Plan\",\n    description=\"100 credits for AI agent access\"\n)\n\n# Price: 20 tokens (ERC20)\nprice_config = get_erc20_price_config(\n    amount=20,\n    token_address=\"0xYourERC20TokenAddress\",\n    receiver=\"0xYourWalletAddress\"\n)\n\n# Credits: 100 credits, 1 credit per request\ncredits_config = get_fixed_credits_config(\n    credits_granted=100,\n    credits_per_request=1\n)\n\n# Register the plan\nresult = payments.plans.register_credits_plan(\n    plan_metadata=plan_metadata,\n    price_config=price_config,\n    credits_config=credits_config\n)\nprint(f\"Plan ID: {result['planId']}\")\n</code></pre>"},{"location":"api/03-payment-plans/#time-plans","title":"Time Plans","text":"<p>Time plans grant users unlimited access for a specific duration:</p> <pre><code>from payments_py.plans import get_expirable_duration_config, ONE_DAY_DURATION\n\n# Price configuration\nprice_config = get_erc20_price_config(\n    amount=50,\n    token_address=\"0xYourERC20TokenAddress\",\n    receiver=\"0xYourWalletAddress\"\n)\n\n# Duration: 1 day\ncredits_config = get_expirable_duration_config(ONE_DAY_DURATION)\n\nresult = payments.plans.register_time_plan(\n    plan_metadata=PlanMetadata(name=\"Daily Plan\"),\n    price_config=price_config,\n    credits_config=credits_config\n)\n</code></pre>"},{"location":"api/03-payment-plans/#trial-plans","title":"Trial Plans","text":"<p>Trial plans can only be purchased once per user. Perfect for free trials:</p> <pre><code>from payments_py.plans import get_free_price_config\n\n# Free trial with 10 credits\nprice_config = get_free_price_config()\ncredits_config = get_fixed_credits_config(credits_granted=10)\n\nresult = payments.plans.register_credits_trial_plan(\n    plan_metadata=PlanMetadata(name=\"Free Trial\", description=\"10 free credits\"),\n    price_config=price_config,\n    credits_config=credits_config\n)\n</code></pre> <pre><code># Free trial with 1 day access\ncredits_config = get_expirable_duration_config(ONE_DAY_DURATION)\n\nresult = payments.plans.register_time_trial_plan(\n    plan_metadata=PlanMetadata(name=\"1-Day Trial\"),\n    price_config=get_free_price_config(),\n    credits_config=credits_config\n)\n</code></pre>"},{"location":"api/03-payment-plans/#price-configuration","title":"Price Configuration","text":""},{"location":"api/03-payment-plans/#erc20-token-price","title":"ERC20 Token Price","text":"<pre><code>from payments_py.plans import get_erc20_price_config\n\nprice_config = get_erc20_price_config(\n    amount=100,                           # Amount in token units\n    token_address=\"0xTokenAddress\",       # ERC20 token contract\n    receiver=\"0xBuilderAddress\"           # Payment receiver\n)\n</code></pre>"},{"location":"api/03-payment-plans/#native-token-price-eth","title":"Native Token Price (ETH)","text":"<pre><code>from payments_py.plans import get_native_token_price_config\n\nprice_config = get_native_token_price_config(\n    amount=1000000000000000,  # Amount in wei (0.001 ETH)\n    receiver=\"0xBuilderAddress\"\n)\n</code></pre>"},{"location":"api/03-payment-plans/#fiat-price-usd","title":"Fiat Price (USD)","text":"<pre><code>from payments_py.plans import get_fiat_price_config\n\nprice_config = get_fiat_price_config(\n    amount=999,  # $9.99 in cents\n    receiver=\"0xBuilderAddress\"\n)\n</code></pre>"},{"location":"api/03-payment-plans/#free-price","title":"Free Price","text":"<pre><code>from payments_py.plans import get_free_price_config\n\nprice_config = get_free_price_config()\n</code></pre>"},{"location":"api/03-payment-plans/#credits-configuration","title":"Credits Configuration","text":""},{"location":"api/03-payment-plans/#fixed-credits","title":"Fixed Credits","text":"<p>Each request consumes a fixed number of credits:</p> <pre><code>from payments_py.plans import get_fixed_credits_config\n\ncredits_config = get_fixed_credits_config(\n    credits_granted=100,      # Total credits granted\n    credits_per_request=1     # Credits consumed per request\n)\n</code></pre>"},{"location":"api/03-payment-plans/#dynamic-credits","title":"Dynamic Credits","text":"<p>Each request can consume a variable number of credits:</p> <pre><code>from payments_py.plans import get_dynamic_credits_config\n\ncredits_config = get_dynamic_credits_config(\n    credits_granted=100,\n    min_credits_per_request=1,   # Minimum credits per request\n    max_credits_per_request=10   # Maximum credits per request\n)\n</code></pre>"},{"location":"api/03-payment-plans/#duration-based-time-plans","title":"Duration-Based (Time Plans)","text":"<pre><code>from payments_py.plans import (\n    get_expirable_duration_config,\n    get_non_expirable_duration_config,\n    ONE_DAY_DURATION,\n    ONE_WEEK_DURATION,\n    ONE_MONTH_DURATION,\n    ONE_YEAR_DURATION\n)\n\n# Expirable (time-limited)\ncredits_config = get_expirable_duration_config(ONE_MONTH_DURATION)\n\n# Non-expirable (permanent access)\ncredits_config = get_non_expirable_duration_config()\n</code></pre>"},{"location":"api/03-payment-plans/#retrieve-plans","title":"Retrieve Plans","text":""},{"location":"api/03-payment-plans/#get-a-single-plan","title":"Get a Single Plan","text":"<pre><code>plan = payments.plans.get_plan(plan_id=\"123456\")\nprint(f\"Plan name: {plan['name']}\")\nprint(f\"Plan type: {plan['planType']}\")\n</code></pre>"},{"location":"api/03-payment-plans/#get-plan-balance","title":"Get Plan Balance","text":"<p>Check the balance for a specific account:</p> <pre><code>balance = payments.plans.get_plan_balance(\n    plan_id=\"123456\",\n    account_address=\"0xUserAddress\"  # Optional, defaults to current user\n)\nprint(f\"Balance: {balance.balance} credits\")\nprint(f\"Is subscriber: {balance.is_subscriber}\")\n</code></pre>"},{"location":"api/03-payment-plans/#get-agents-associated-to-a-plan","title":"Get Agents Associated to a Plan","text":"<pre><code>from payments_py.common.types import PaginationOptions\n\nagents = payments.plans.get_agents_associated_to_plan(\n    plan_id=\"123456\",\n    pagination=PaginationOptions(page=1, offset=10)\n)\nprint(f\"Agents: {agents}\")\n</code></pre>"},{"location":"api/03-payment-plans/#complete-example","title":"Complete Example","text":"<pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.common.types import PlanMetadata\nfrom payments_py.plans import (\n    get_erc20_price_config,\n    get_fixed_credits_config,\n    get_expirable_duration_config,\n    get_free_price_config,\n    ONE_DAY_DURATION\n)\n\n# Initialize\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\nbuilder_address = payments.account_address\n\n# ERC20 token address (use a test token in sandbox)\nERC20_TOKEN = \"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d\"\n\n# 1. Create a credits plan\ncredits_plan = payments.plans.register_credits_plan(\n    plan_metadata=PlanMetadata(name=\"Basic Credits Plan\"),\n    price_config=get_erc20_price_config(20, ERC20_TOKEN, builder_address),\n    credits_config=get_fixed_credits_config(100)\n)\nprint(f\"Credits Plan: {credits_plan['planId']}\")\n\n# 2. Create a time plan\ntime_plan = payments.plans.register_time_plan(\n    plan_metadata=PlanMetadata(name=\"Monthly Plan\"),\n    price_config=get_erc20_price_config(50, ERC20_TOKEN, builder_address),\n    credits_config=get_expirable_duration_config(ONE_DAY_DURATION)\n)\nprint(f\"Time Plan: {time_plan['planId']}\")\n\n# 3. Create a free trial\ntrial_plan = payments.plans.register_credits_trial_plan(\n    plan_metadata=PlanMetadata(name=\"Free Trial\"),\n    price_config=get_free_price_config(),\n    credits_config=get_fixed_credits_config(10)\n)\nprint(f\"Trial Plan: {trial_plan['planId']}\")\n\n# 4. Retrieve plan details\nplan_details = payments.plans.get_plan(credits_plan['planId'])\nprint(f\"Plan details: {plan_details}\")\n</code></pre>"},{"location":"api/03-payment-plans/#next-steps","title":"Next Steps","text":"<ul> <li>Agents - Register AI agents and associate them with plans</li> <li>Payments and Balance - Order plans and manage balances</li> </ul>"},{"location":"api/04-agents/","title":"Agents","text":"<p>This guide covers how to register and manage AI agents using the Nevermined Payments Python SDK.</p>"},{"location":"api/04-agents/#overview","title":"Overview","text":"<p>AI Agents are services that users can access through payment plans. The Agents API allows you to:</p> <ul> <li>Register new agents with associated payment plans</li> <li>Register agents and plans together in a single operation</li> <li>Update agent metadata and endpoints</li> <li>Manage plan associations</li> </ul>"},{"location":"api/04-agents/#agents-api","title":"Agents API","text":"<p>Access the Agents API through <code>payments.agents</code>:</p> <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\n# Access agents API\nagents_api = payments.agents\n</code></pre>"},{"location":"api/04-agents/#register-agents","title":"Register Agents","text":""},{"location":"api/04-agents/#basic-agent-registration","title":"Basic Agent Registration","text":"<p>Register an agent and associate it with existing payment plans:</p> <pre><code>from payments_py.common.types import AgentMetadata, AgentAPIAttributes\n\n# Define agent metadata\nagent_metadata = AgentMetadata(\n    name=\"My AI Assistant\",\n    description=\"An intelligent assistant that helps with various tasks\",\n    tags=[\"ai\", \"assistant\", \"productivity\"],\n    author=\"Your Company\"\n)\n\n# Define API configuration\nagent_api = AgentAPIAttributes(\n    endpoints=[\n        {\"POST\": \"https://your-api.com/api/v1/agents/:agentId/tasks\"},\n        {\"GET\": \"https://your-api.com/api/v1/agents/:agentId/tasks/:taskId\"}\n    ],\n    agent_definition_url=\"https://your-api.com/api/v1/openapi.json\"\n)\n\n# List of plan IDs that grant access to this agent\npayment_plans = [plan_id_1, plan_id_2]\n\n# Register the agent\nresult = payments.agents.register_agent(\n    agent_metadata=agent_metadata,\n    agent_api=agent_api,\n    payment_plans=payment_plans\n)\nprint(f\"Agent ID: {result['agentId']}\")\n</code></pre>"},{"location":"api/04-agents/#register-agent-and-plan-together","title":"Register Agent and Plan Together","text":"<p>Create both an agent and a payment plan in a single operation:</p> <pre><code>from payments_py.common.types import AgentMetadata, AgentAPIAttributes, PlanMetadata\nfrom payments_py.plans import get_erc20_price_config, get_fixed_credits_config\n\n# Agent configuration\nagent_metadata = AgentMetadata(\n    name=\"AI Code Reviewer\",\n    description=\"Automated code review assistant\",\n    tags=[\"code\", \"review\", \"ai\"]\n)\n\nagent_api = AgentAPIAttributes(\n    endpoints=[{\"POST\": \"https://your-api.com/api/v1/review\"}],\n    agent_definition_url=\"https://your-api.com/openapi.json\"\n)\n\n# Plan configuration\nplan_metadata = PlanMetadata(\n    name=\"Code Review Plan\",\n    description=\"100 code reviews\"\n)\n\nprice_config = get_erc20_price_config(\n    amount=50,\n    token_address=\"0xYourTokenAddress\",\n    receiver=payments.account_address\n)\n\ncredits_config = get_fixed_credits_config(credits_granted=100)\n\n# Register both in one call\nresult = payments.agents.register_agent_and_plan(\n    agent_metadata=agent_metadata,\n    agent_api=agent_api,\n    plan_metadata=plan_metadata,\n    price_config=price_config,\n    credits_config=credits_config,\n    access_limit=\"credits\"  # or \"time\"\n)\n\nprint(f\"Agent ID: {result['agentId']}\")\nprint(f\"Plan ID: {result['planId']}\")\nprint(f\"Transaction: {result['txHash']}\")\n</code></pre>"},{"location":"api/04-agents/#agent-configuration","title":"Agent Configuration","text":""},{"location":"api/04-agents/#agentmetadata-fields","title":"AgentMetadata Fields","text":"Field Type Required Description <code>name</code> <code>str</code> Yes Agent display name <code>description</code> <code>str</code> No Agent description <code>author</code> <code>str</code> No Author/company name <code>tags</code> <code>list[str]</code> No Categorization tags <code>license</code> <code>str</code> No License information <code>sample_link</code> <code>str</code> No Link to demo/sample <code>api_description</code> <code>str</code> No API documentation"},{"location":"api/04-agents/#agentapiattributes-fields","title":"AgentAPIAttributes Fields","text":"Field Type Required Description <code>endpoints</code> <code>list[dict]</code> Yes List of endpoint configurations <code>agent_definition_url</code> <code>str</code> Yes URL to OpenAPI/MCP/A2A spec <code>open_endpoints</code> <code>list[str]</code> No Endpoints without auth <code>auth_type</code> <code>AuthType</code> No Authentication type"},{"location":"api/04-agents/#endpoint-configuration","title":"Endpoint Configuration","text":"<p>Endpoints are defined as dictionaries with HTTP verb as key and URL as value:</p> <pre><code>agent_api = AgentAPIAttributes(\n    endpoints=[\n        {\"POST\": \"https://api.example.com/agents/:agentId/tasks\"},\n        {\"GET\": \"https://api.example.com/agents/:agentId/tasks/:taskId\"},\n        {\"DELETE\": \"https://api.example.com/agents/:agentId/tasks/:taskId\"}\n    ],\n    agent_definition_url=\"https://api.example.com/openapi.json\"\n)\n</code></pre> <p>The <code>:agentId</code> and <code>:taskId</code> placeholders will be replaced with actual values during request validation.</p>"},{"location":"api/04-agents/#retrieve-agents","title":"Retrieve Agents","text":""},{"location":"api/04-agents/#get-a-single-agent","title":"Get a Single Agent","text":"<pre><code>agent = payments.agents.get_agent(agent_id=\"your-agent-id\")\nprint(f\"Agent name: {agent['name']}\")\nprint(f\"Agent endpoints: {agent['endpoints']}\")\n</code></pre>"},{"location":"api/04-agents/#get-plans-for-an-agent","title":"Get Plans for an Agent","text":"<pre><code>from payments_py.common.types import PaginationOptions\n\nplans = payments.agents.get_agent_plans(\n    agent_id=\"your-agent-id\",\n    pagination=PaginationOptions(page=1, offset=10)\n)\nprint(f\"Associated plans: {plans}\")\n</code></pre>"},{"location":"api/04-agents/#update-agents","title":"Update Agents","text":""},{"location":"api/04-agents/#update-agent-metadata","title":"Update Agent Metadata","text":"<pre><code>updated_metadata = AgentMetadata(\n    name=\"Updated Agent Name\",\n    description=\"Updated description with new features\",\n    tags=[\"ai\", \"updated\", \"v2\"]\n)\n\nupdated_api = AgentAPIAttributes(\n    endpoints=[{\"POST\": \"https://new-api.com/v2/tasks\"}],\n    agent_definition_url=\"https://new-api.com/v2/openapi.json\"\n)\n\nresult = payments.agents.update_agent_metadata(\n    agent_id=\"your-agent-id\",\n    agent_metadata=updated_metadata,\n    agent_api=updated_api\n)\nprint(f\"Update successful: {result}\")\n</code></pre>"},{"location":"api/04-agents/#manage-plan-associations","title":"Manage Plan Associations","text":""},{"location":"api/04-agents/#add-a-plan-to-an-agent","title":"Add a Plan to an Agent","text":"<pre><code>result = payments.agents.add_plan_to_agent(\n    plan_id=\"plan-to-add\",\n    agent_id=\"your-agent-id\"\n)\nprint(f\"Plan added: {result}\")\n</code></pre>"},{"location":"api/04-agents/#remove-a-plan-from-an-agent","title":"Remove a Plan from an Agent","text":"<pre><code>result = payments.agents.remove_plan_from_agent(\n    plan_id=\"plan-to-remove\",\n    agent_id=\"your-agent-id\"\n)\nprint(f\"Plan removed: {result}\")\n</code></pre>"},{"location":"api/04-agents/#complete-example","title":"Complete Example","text":"<pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.common.types import AgentMetadata, AgentAPIAttributes, PlanMetadata\nfrom payments_py.plans import (\n    get_erc20_price_config,\n    get_fixed_credits_config,\n    get_free_price_config\n)\n\n# Initialize\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\nERC20_TOKEN = \"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d\"\nbuilder_address = payments.account_address\n\n# 1. Create a payment plan first\nplan_result = payments.plans.register_credits_plan(\n    plan_metadata=PlanMetadata(name=\"AI Agent Plan\"),\n    price_config=get_erc20_price_config(20, ERC20_TOKEN, builder_address),\n    credits_config=get_fixed_credits_config(100)\n)\nplan_id = plan_result['planId']\n\n# 2. Register an agent with the plan\nagent_result = payments.agents.register_agent(\n    agent_metadata=AgentMetadata(\n        name=\"My First AI Agent\",\n        description=\"A demo AI agent\",\n        tags=[\"demo\", \"ai\"]\n    ),\n    agent_api=AgentAPIAttributes(\n        endpoints=[{\"POST\": \"https://api.example.com/agents/:agentId/tasks\"}],\n        agent_definition_url=\"https://api.example.com/openapi.json\"\n    ),\n    payment_plans=[plan_id]\n)\nagent_id = agent_result['agentId']\nprint(f\"Created agent: {agent_id}\")\n\n# 3. Or create both together\ncombo_result = payments.agents.register_agent_and_plan(\n    agent_metadata=AgentMetadata(name=\"Combo Agent\"),\n    agent_api=AgentAPIAttributes(\n        endpoints=[{\"POST\": \"https://api.example.com/combo\"}],\n        agent_definition_url=\"https://api.example.com/openapi.json\"\n    ),\n    plan_metadata=PlanMetadata(name=\"Combo Plan\"),\n    price_config=get_free_price_config(),\n    credits_config=get_fixed_credits_config(10)\n)\nprint(f\"Combo Agent: {combo_result['agentId']}, Plan: {combo_result['planId']}\")\n\n# 4. Retrieve agent details\nagent = payments.agents.get_agent(agent_id)\nprint(f\"Agent details: {agent}\")\n\n# 5. Get associated plans\nplans = payments.agents.get_agent_plans(agent_id)\nprint(f\"Agent plans: {plans}\")\n\n# 6. Update agent metadata\npayments.agents.update_agent_metadata(\n    agent_id=agent_id,\n    agent_metadata=AgentMetadata(name=\"Updated Agent Name\"),\n    agent_api=AgentAPIAttributes(\n        endpoints=[{\"POST\": \"https://api.example.com/v2/agents/:agentId/tasks\"}],\n        agent_definition_url=\"https://api.example.com/v2/openapi.json\"\n    )\n)\n</code></pre>"},{"location":"api/04-agents/#next-steps","title":"Next Steps","text":"<ul> <li>Publishing Static Resources - Publish files and datasets</li> <li>Querying an Agent - Learn how to access agents</li> </ul>"},{"location":"api/05-publishing-static-resources/","title":"Publishing Static Resources","text":"<p>This guide explains how to publish static resources (files, datasets) using the Nevermined Payments Python SDK.</p>"},{"location":"api/05-publishing-static-resources/#overview","title":"Overview","text":"<p>Static resources are files or datasets that users can access through payment plans. Unlike AI agents that process requests, static resources are downloadable content such as:</p> <ul> <li>Documents (PDFs, reports)</li> <li>Datasets (CSV, JSON files)</li> <li>Media files (images, videos)</li> <li>Software packages</li> </ul>"},{"location":"api/05-publishing-static-resources/#register-static-resource-agents","title":"Register Static Resource Agents","text":"<p>Static resources are registered as a special type of agent with file endpoints:</p> <pre><code>from payments_py.common.types import AgentMetadata, AgentAPIAttributes\n\n# Resource metadata\nresource_metadata = AgentMetadata(\n    name=\"Premium Dataset Collection\",\n    description=\"A curated collection of ML training datasets\",\n    tags=[\"dataset\", \"machine-learning\", \"premium\"]\n)\n\n# Static file endpoints\nresource_api = AgentAPIAttributes(\n    endpoints=[\n        {\"GET\": \"https://storage.example.com/datasets/training-data.csv\"},\n        {\"GET\": \"https://storage.example.com/datasets/validation-data.csv\"},\n        {\"GET\": \"https://storage.example.com/datasets/test-data.csv\"}\n    ],\n    agent_definition_url=\"https://storage.example.com/datasets/manifest.json\"\n)\n\n# Register with a payment plan\nresult = payments.agents.register_agent(\n    agent_metadata=resource_metadata,\n    agent_api=resource_api,\n    payment_plans=[plan_id]\n)\nprint(f\"Resource ID: {result['agentId']}\")\n</code></pre>"},{"location":"api/05-publishing-static-resources/#using-wildcards-for-multiple-files","title":"Using Wildcards for Multiple Files","text":"<p>When you have multiple files that follow a pattern, you can use wildcard URLs:</p> <pre><code># Single wildcard for dynamic file names\nresource_api = AgentAPIAttributes(\n    endpoints=[\n        # Matches: /files/report-001.pdf, /files/report-2024.pdf, etc.\n        {\"GET\": \"https://storage.example.com/files/report-*.pdf\"},\n\n        # Matches: /data/dataset_v1.csv, /data/dataset_v2.csv, etc.\n        {\"GET\": \"https://storage.example.com/data/dataset_*.csv\"}\n    ],\n    agent_definition_url=\"https://storage.example.com/manifest.json\"\n)\n</code></pre>"},{"location":"api/05-publishing-static-resources/#wildcard-patterns","title":"Wildcard Patterns","text":"Pattern Matches <code>*.pdf</code> Any PDF file <code>report-*.pdf</code> report-001.pdf, report-2024.pdf <code>data/*.csv</code> All CSV files in data folder <code>v*/data.json</code> v1/data.json, v2/data.json"},{"location":"api/05-publishing-static-resources/#complete-example-dataset-publishing","title":"Complete Example: Dataset Publishing","text":"<pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.common.types import AgentMetadata, AgentAPIAttributes, PlanMetadata\nfrom payments_py.plans import get_erc20_price_config, get_fixed_credits_config\n\n# Initialize\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\nERC20_TOKEN = \"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d\"\nbuilder_address = payments.account_address\n\n# 1. Create a plan for the dataset\nplan_result = payments.plans.register_credits_plan(\n    plan_metadata=PlanMetadata(\n        name=\"Dataset Access Plan\",\n        description=\"Access to premium ML datasets\"\n    ),\n    price_config=get_erc20_price_config(100, ERC20_TOKEN, builder_address),\n    credits_config=get_fixed_credits_config(10)  # 10 downloads\n)\nplan_id = plan_result['planId']\n\n# 2. Register the dataset resource\ndataset_result = payments.agents.register_agent(\n    agent_metadata=AgentMetadata(\n        name=\"ML Training Datasets\",\n        description=\"High-quality labeled datasets for machine learning\",\n        tags=[\"dataset\", \"ml\", \"training\", \"labeled\"]\n    ),\n    agent_api=AgentAPIAttributes(\n        endpoints=[\n            {\"GET\": \"https://storage.example.com/datasets/images/*.zip\"},\n            {\"GET\": \"https://storage.example.com/datasets/text/*.jsonl\"},\n            {\"GET\": \"https://storage.example.com/datasets/audio/*.tar.gz\"}\n        ],\n        agent_definition_url=\"https://storage.example.com/datasets/catalog.json\"\n    ),\n    payment_plans=[plan_id]\n)\nprint(f\"Dataset Resource ID: {dataset_result['agentId']}\")\n</code></pre>"},{"location":"api/05-publishing-static-resources/#example-document-repository","title":"Example: Document Repository","text":"<pre><code># Publishing a document repository\ndoc_result = payments.agents.register_agent(\n    agent_metadata=AgentMetadata(\n        name=\"Research Papers Collection\",\n        description=\"Exclusive research papers and technical reports\",\n        tags=[\"research\", \"papers\", \"technical\"]\n    ),\n    agent_api=AgentAPIAttributes(\n        endpoints=[\n            # Specific documents\n            {\"GET\": \"https://docs.example.com/papers/whitepaper-2024.pdf\"},\n            {\"GET\": \"https://docs.example.com/papers/research-findings.pdf\"},\n\n            # Wildcard for quarterly reports\n            {\"GET\": \"https://docs.example.com/reports/q*-report.pdf\"},\n\n            # All supplementary materials\n            {\"GET\": \"https://docs.example.com/supplementary/*.zip\"}\n        ],\n        agent_definition_url=\"https://docs.example.com/index.json\"\n    ),\n    payment_plans=[plan_id]\n)\n</code></pre>"},{"location":"api/05-publishing-static-resources/#example-software-distribution","title":"Example: Software Distribution","text":"<pre><code># Publishing software packages\nsoftware_result = payments.agents.register_agent(\n    agent_metadata=AgentMetadata(\n        name=\"Premium Software Tools\",\n        description=\"Professional development tools and utilities\",\n        tags=[\"software\", \"tools\", \"professional\"]\n    ),\n    agent_api=AgentAPIAttributes(\n        endpoints=[\n            # Version-specific downloads\n            {\"GET\": \"https://releases.example.com/tool/v*/tool-*.zip\"},\n\n            # Platform-specific binaries\n            {\"GET\": \"https://releases.example.com/tool/latest/tool-linux-*.tar.gz\"},\n            {\"GET\": \"https://releases.example.com/tool/latest/tool-macos-*.dmg\"},\n            {\"GET\": \"https://releases.example.com/tool/latest/tool-windows-*.exe\"},\n\n            # Documentation\n            {\"GET\": \"https://releases.example.com/tool/docs/*.pdf\"}\n        ],\n        agent_definition_url=\"https://releases.example.com/tool/manifest.json\"\n    ),\n    payment_plans=[plan_id]\n)\n</code></pre>"},{"location":"api/05-publishing-static-resources/#accessing-static-resources","title":"Accessing Static Resources","text":"<p>For details on how subscribers access static resources using x402 access tokens, see Request Validation.</p>"},{"location":"api/05-publishing-static-resources/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use descriptive metadata: Include clear names, descriptions, and tags for discoverability</p> </li> <li> <p>Organize files logically: Use consistent URL patterns that work well with wildcards</p> </li> <li> <p>Version your resources: Include version numbers in URLs for easy updates</p> </li> <li> <p>Provide a manifest: Create a JSON manifest at the <code>agent_definition_url</code> listing all available files</p> </li> <li> <p>Set appropriate credits: Consider the value and size of files when setting credit costs</p> </li> </ol>"},{"location":"api/05-publishing-static-resources/#next-steps","title":"Next Steps","text":"<ul> <li>Payments and Balance - Order plans and check balances</li> <li>Querying an Agent - Access resources with tokens</li> </ul>"},{"location":"api/06-payments-and-balance/","title":"Payments and Balance","text":"<p>This guide covers how to order payment plans and manage balances using the Nevermined Payments Python SDK.</p>"},{"location":"api/06-payments-and-balance/#overview","title":"Overview","text":"<p>As a subscriber, you need to order payment plans to gain access to AI agents and resources. This guide explains:</p> <ul> <li>How to check plan balances</li> <li>How to order plans (crypto payments)</li> <li>How to mint and burn credits (for plan owners)</li> </ul>"},{"location":"api/06-payments-and-balance/#check-plan-balance","title":"Check Plan Balance","text":"<p>Before ordering or using a plan, check the current balance:</p> <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\n# Check balance for current user\nbalance = payments.plans.get_plan_balance(plan_id=\"your-plan-id\")\n\nprint(f\"Plan ID: {balance.plan_id}\")\nprint(f\"Plan Name: {balance.plan_name}\")\nprint(f\"Plan Type: {balance.plan_type}\")\nprint(f\"Balance: {balance.balance}\")\nprint(f\"Is Subscriber: {balance.is_subscriber}\")\nprint(f\"Price per Credit: {balance.price_per_credit}\")\n</code></pre>"},{"location":"api/06-payments-and-balance/#check-balance-for-another-user","title":"Check Balance for Another User","text":"<pre><code>balance = payments.plans.get_plan_balance(\n    plan_id=\"your-plan-id\",\n    account_address=\"0xOtherUserAddress\"\n)\n</code></pre>"},{"location":"api/06-payments-and-balance/#balance-response-fields","title":"Balance Response Fields","text":"Field Type Description <code>plan_id</code> <code>str</code> Plan identifier <code>plan_name</code> <code>str</code> Plan display name <code>plan_type</code> <code>str</code> \"credits\" or \"time\" <code>balance</code> <code>int</code> Current credit balance <code>is_subscriber</code> <code>bool</code> Whether user has access <code>holder_address</code> <code>str</code> Wallet address checked <code>price_per_credit</code> <code>float</code> Cost per credit"},{"location":"api/06-payments-and-balance/#order-plans","title":"Order Plans","text":""},{"location":"api/06-payments-and-balance/#order-with-crypto","title":"Order with Crypto","text":"<p>Order a plan using cryptocurrency (ERC20 or native tokens):</p> <pre><code># Order a plan (requires sufficient token balance)\nresult = payments.plans.order_plan(plan_id=\"your-plan-id\")\n\nprint(f\"Success: {result['success']}\")\nprint(f\"Order details: {result}\")\n</code></pre> <p>Token Approval Required</p> <p>For ERC20 token payments, ensure you have approved the Nevermined contract to spend your tokens before ordering.</p>"},{"location":"api/06-payments-and-balance/#order-fiat-plans","title":"Order Fiat Plans","text":"<p>For plans priced in fiat (USD), use Stripe checkout:</p> <pre><code># Get Stripe checkout session\ncheckout = payments.plans.order_fiat_plan(plan_id=\"fiat-plan-id\")\n\nprint(f\"Checkout URL: {checkout['checkoutUrl']}\")\nprint(f\"Session ID: {checkout['sessionId']}\")\n\n# Redirect user to checkout['checkoutUrl'] to complete payment\n</code></pre>"},{"location":"api/06-payments-and-balance/#mint-credits-plan-owners","title":"Mint Credits (Plan Owners)","text":"<p>Plan owners can mint additional credits for subscribers:</p> <pre><code># Mint credits to a user\nresult = payments.plans.mint_plan_credits(\n    plan_id=\"your-plan-id\",\n    credits_amount=50,\n    credits_receiver=\"0xSubscriberAddress\"\n)\n\nprint(f\"Minted: {result}\")\n</code></pre>"},{"location":"api/06-payments-and-balance/#mint-expirable-credits","title":"Mint Expirable Credits","text":"<p>For time-limited plans, mint credits with an expiration:</p> <pre><code>result = payments.plans.mint_plan_expirable(\n    plan_id=\"your-plan-id\",\n    credits_amount=100,\n    credits_receiver=\"0xSubscriberAddress\",\n    credits_duration=86400  # 1 day in seconds\n)\n</code></pre>"},{"location":"api/06-payments-and-balance/#burn-credits-plan-owners","title":"Burn Credits (Plan Owners)","text":"<p>Plan owners can burn credits from the plan:</p> <pre><code>result = payments.plans.burn_credits(\n    plan_id=\"your-plan-id\",\n    credits_amount=\"10\"\n)\n\nprint(f\"Burned: {result}\")\n</code></pre>"},{"location":"api/06-payments-and-balance/#redeem-credits","title":"Redeem Credits","text":"<p>Agents can redeem credits from subscribers for completed work:</p> <pre><code>result = payments.plans.redeem_credits(\n    agent_request_id=\"request-123\",\n    plan_id=\"plan-id\",\n    redeem_from=\"0xSubscriberAddress\",\n    credits_amount_to_redeem=\"5\"\n)\n</code></pre>"},{"location":"api/06-payments-and-balance/#complete-example","title":"Complete Example","text":"<pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.common.types import PlanMetadata\nfrom payments_py.plans import get_erc20_price_config, get_fixed_credits_config\n\n# Initialize as builder (plan owner)\npayments_builder = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:builder-key\", environment=\"sandbox\")\n)\n\n# Initialize as subscriber\npayments_subscriber = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n)\n\nERC20_TOKEN = \"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d\"\nbuilder_address = payments_builder.account_address\n\n# 1. Builder creates a plan\nplan_result = payments_builder.plans.register_credits_plan(\n    plan_metadata=PlanMetadata(name=\"Premium Plan\"),\n    price_config=get_erc20_price_config(20, ERC20_TOKEN, builder_address),\n    credits_config=get_fixed_credits_config(100)\n)\nplan_id = plan_result['planId']\nprint(f\"Created plan: {plan_id}\")\n\n# 2. Subscriber checks initial balance (should be 0 or not subscribed)\ninitial_balance = payments_subscriber.plans.get_plan_balance(plan_id)\nprint(f\"Initial balance: {initial_balance.balance}\")\nprint(f\"Is subscriber: {initial_balance.is_subscriber}\")\n\n# 3. Subscriber orders the plan\norder_result = payments_subscriber.plans.order_plan(plan_id)\nprint(f\"Order success: {order_result['success']}\")\n\n# 4. Subscriber checks balance after ordering\nfinal_balance = payments_subscriber.plans.get_plan_balance(plan_id)\nprint(f\"Final balance: {final_balance.balance}\")\nprint(f\"Is subscriber: {final_balance.is_subscriber}\")\n\n# 5. Builder can mint additional credits\nif final_balance.is_subscriber:\n    mint_result = payments_builder.plans.mint_plan_credits(\n        plan_id=plan_id,\n        credits_amount=50,\n        credits_receiver=payments_subscriber.account_address\n    )\n    print(f\"Minted 50 additional credits\")\n\n    # Check updated balance\n    updated_balance = payments_subscriber.plans.get_plan_balance(plan_id)\n    print(f\"Updated balance: {updated_balance.balance}\")\n</code></pre>"},{"location":"api/06-payments-and-balance/#workflow-summary","title":"Workflow Summary","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     BUILDER                               \u2502\n\u2502  1. Create Plan (register_credits_plan)                  \u2502\n\u2502  2. Register Agent with Plan                             \u2502\n\u2502  3. Optionally mint credits to users                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    SUBSCRIBER                             \u2502\n\u2502  1. Check Balance (get_plan_balance)                     \u2502\n\u2502  2. Order Plan (order_plan)                              \u2502\n\u2502  3. Get Access Token (get_x402_access_token)             \u2502\n\u2502  4. Query Agent (with access token)                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/06-payments-and-balance/#next-steps","title":"Next Steps","text":"<ul> <li>Querying an Agent - Get access tokens and make requests</li> <li>Request Validation - How agents validate requests</li> </ul>"},{"location":"api/07-querying-an-agent/","title":"Querying an Agent","text":"<p>This guide explains how to get x402 access tokens and make authenticated requests to AI agents.</p>"},{"location":"api/07-querying-an-agent/#overview","title":"Overview","text":"<p>To query an AI agent, subscribers need to:</p> <ol> <li>Have an active subscription to a plan associated with the agent</li> <li>Generate an x402 access token</li> <li>Include the token in requests to the agent</li> </ol>"},{"location":"api/07-querying-an-agent/#get-x402-access-token","title":"Get X402 Access Token","text":"<p>The x402 access token authorizes requests to agents and enables credit verification/settlement.</p> <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n)\n\n# Generate access token\nresult = payments.x402.get_x402_access_token(\n    plan_id=\"your-plan-id\",\n    agent_id=\"agent-id\"  # Optional but recommended\n)\n\naccess_token = result['accessToken']\nprint(f\"Access Token: {access_token[:50]}...\")\n</code></pre>"},{"location":"api/07-querying-an-agent/#token-generation-parameters","title":"Token Generation Parameters","text":"Parameter Type Required Description <code>plan_id</code> <code>str</code> Yes The payment plan ID <code>agent_id</code> <code>str</code> No Target agent ID (recommended) <code>redemption_limit</code> <code>int</code> No Max number of redemptions <code>order_limit</code> <code>str</code> No Max spend in wei <code>expiration</code> <code>str</code> No ISO 8601 expiration date"},{"location":"api/07-querying-an-agent/#advanced-token-options","title":"Advanced Token Options","text":"<pre><code>from datetime import datetime, timedelta\n\n# Token with limits and expiration\nresult = payments.x402.get_x402_access_token(\n    plan_id=\"your-plan-id\",\n    agent_id=\"agent-id\",\n    redemption_limit=10,  # Max 10 requests\n    order_limit=\"1000000000000000000\",  # Max 1 token in wei\n    expiration=(datetime.now() + timedelta(hours=24)).isoformat()\n)\n</code></pre>"},{"location":"api/07-querying-an-agent/#make-requests-to-agents","title":"Make Requests to Agents","text":""},{"location":"api/07-querying-an-agent/#using-the-x402-payment-header","title":"Using the x402 Payment Header","text":"<p>Include the access token in the <code>payment-signature</code> header (per x402 v2 HTTP transport spec):</p> <pre><code>import requests\n\n# Get access token\ntoken_result = payments.x402.get_x402_access_token(\n    plan_id=plan_id,\n    agent_id=agent_id\n)\naccess_token = token_result['accessToken']\n\n# Make request to the agent\nresponse = requests.post(\n    f\"https://agent-api.example.com/agents/{agent_id}/tasks\",\n    headers={\n        \"payment-signature\": access_token,\n        \"Content-Type\": \"application/json\"\n    },\n    json={\n        \"task\": \"Analyze this data\",\n        \"data\": {\"key\": \"value\"}\n    }\n)\n\nif response.status_code == 200:\n    result = response.json()\n    print(f\"Agent response: {result}\")\nelif response.status_code == 402:\n    print(\"Payment required - check plan balance\")\nelse:\n    print(f\"Error: {response.status_code}\")\n</code></pre>"},{"location":"api/07-querying-an-agent/#decode-access-token","title":"Decode Access Token","text":"<p>You can decode the token to inspect its contents:</p> <pre><code>from payments_py.x402.token import decode_access_token\n\ndecoded = decode_access_token(access_token)\n\nif decoded:\n    payload = decoded.get('payload', {})\n    authorization = payload.get('authorization', {})\n\n    print(f\"Subscriber: {authorization.get('from')}\")\n    print(f\"Plan ID: {authorization.get('planId')}\")\n    print(f\"Agent ID: {authorization.get('agentId')}\")\n</code></pre>"},{"location":"api/07-querying-an-agent/#complete-example","title":"Complete Example","text":"<pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.common.types import PlanMetadata, AgentMetadata, AgentAPIAttributes\nfrom payments_py.plans import get_free_price_config, get_fixed_credits_config\nimport requests\n\n# Initialize as builder\nbuilder = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:builder-key\", environment=\"sandbox\")\n)\n\n# Initialize as subscriber\nsubscriber = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n)\n\n# 1. Builder creates plan and agent\nplan_result = builder.plans.register_credits_plan(\n    plan_metadata=PlanMetadata(name=\"API Access Plan\"),\n    price_config=get_free_price_config(),  # Free for demo\n    credits_config=get_fixed_credits_config(100)\n)\nplan_id = plan_result['planId']\n\nagent_result = builder.agents.register_agent(\n    agent_metadata=AgentMetadata(name=\"Demo Agent\"),\n    agent_api=AgentAPIAttributes(\n        endpoints=[{\"POST\": \"https://api.example.com/tasks\"}],\n        agent_definition_url=\"https://api.example.com/openapi.json\"\n    ),\n    payment_plans=[plan_id]\n)\nagent_id = agent_result['agentId']\n\n# 2. Subscriber orders the plan\nsubscriber.plans.order_plan(plan_id)\n\n# 3. Subscriber generates access token\ntoken_result = subscriber.x402.get_x402_access_token(\n    plan_id=plan_id,\n    agent_id=agent_id\n)\naccess_token = token_result['accessToken']\n\n# 4. Subscriber makes request to agent\nresponse = requests.post(\n    \"https://api.example.com/tasks\",\n    headers={\n        \"payment-signature\": access_token,\n        \"Content-Type\": \"application/json\"\n    },\n    json={\"prompt\": \"Hello, agent!\"}\n)\n\nprint(f\"Status: {response.status_code}\")\nprint(f\"Response: {response.json()}\")\n\n# 5. Check updated balance\nbalance = subscriber.plans.get_plan_balance(plan_id)\nprint(f\"Remaining credits: {balance.balance}\")\n</code></pre>"},{"location":"api/07-querying-an-agent/#error-handling","title":"Error Handling","text":""},{"location":"api/07-querying-an-agent/#402-payment-required","title":"402 Payment Required","text":"<pre><code>response = requests.post(agent_endpoint, headers=headers, json=payload)\n\nif response.status_code == 402:\n    error = response.json()\n    print(f\"Payment required: {error}\")\n\n    # Check balance\n    balance = payments.plans.get_plan_balance(plan_id)\n    if balance.balance &lt;= 0:\n        print(\"No credits remaining - order more credits\")\n    elif not balance.is_subscriber:\n        print(\"Not subscribed - order the plan first\")\n</code></pre>"},{"location":"api/07-querying-an-agent/#token-expired-or-invalid","title":"Token Expired or Invalid","text":"<pre><code>try:\n    response = requests.post(agent_endpoint, headers=headers, json=payload)\n    response.raise_for_status()\nexcept requests.HTTPError as e:\n    if e.response.status_code == 401:\n        print(\"Token expired or invalid - generate a new token\")\n        # Regenerate token\n        new_token = payments.x402.get_x402_access_token(plan_id, agent_id)\n</code></pre>"},{"location":"api/07-querying-an-agent/#request-flow-diagram","title":"Request Flow Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Subscriber  \u2502     \u2502   Nevermined \u2502     \u2502    Agent     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                    \u2502                    \u2502\n       \u2502 get_x402_access_token()                 \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502                    \u2502\n       \u2502                    \u2502                    \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502                    \u2502\n       \u2502   accessToken      \u2502                    \u2502\n       \u2502                    \u2502                    \u2502\n       \u2502 POST /tasks (payment-signature header)  \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\n       \u2502                    \u2502                    \u2502\n       \u2502                    \u2502  verify_permissions\u2502\n       \u2502                    \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n       \u2502                    \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                    \u2502                    \u2502\n       \u2502                    \u2502  settle_permissions\u2502\n       \u2502                    \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n       \u2502                    \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                    \u2502                    \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       \u2502         Response                       \u2502\n       \u2502                    \u2502                    \u2502\n</code></pre>"},{"location":"api/07-querying-an-agent/#next-steps","title":"Next Steps","text":"<ul> <li>Request Validation - How agents validate incoming requests</li> <li>x402 Protocol - Deep dive into x402 verification and settlement</li> </ul>"},{"location":"api/08-validation-of-requests/","title":"Request Validation","text":"<p>This guide explains how AI agents can validate incoming requests using the Nevermined Payments Python SDK.</p>"},{"location":"api/08-validation-of-requests/#overview","title":"Overview","text":"<p>When an agent receives a request, it needs to:</p> <ol> <li>Extract the x402 access token from the request</li> <li>Verify the subscriber has valid permissions</li> <li>Optionally settle (burn) credits after processing</li> </ol> <p>The SDK provides the Facilitator API for these operations.</p>"},{"location":"api/08-validation-of-requests/#receiving-requests","title":"Receiving Requests","text":"<p>Agents receive requests with the x402 access token in the <code>payment-signature</code> header (per x402 v2 HTTP transport spec):</p> <pre><code>from flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/tasks', methods=['POST'])\ndef handle_task():\n    # Extract x402 token from payment-signature header\n    x402_token = request.headers.get('payment-signature', '')\n\n    if not x402_token:\n        return jsonify({'error': 'Missing payment-signature header'}), 402\n\n    # Validate and process...\n</code></pre>"},{"location":"api/08-validation-of-requests/#validating-requests-with-facilitator","title":"Validating Requests with Facilitator","text":""},{"location":"api/08-validation-of-requests/#build-payment-required-object","title":"Build Payment Required Object","text":"<p>First, build the payment requirement specification:</p> <pre><code>from payments_py.x402.helpers import build_payment_required\n\npayment_required = build_payment_required(\n    plan_id=\"your-plan-id\",\n    endpoint=\"https://your-api.com/tasks\",\n    agent_id=\"your-agent-id\",\n    http_verb=\"POST\"\n)\n</code></pre>"},{"location":"api/08-validation-of-requests/#verify-permissions","title":"Verify Permissions","text":"<p>Check if the subscriber has valid permissions without burning credits:</p> <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:agent-key\", environment=\"sandbox\")\n)\n\n# Verify the request\nverification = payments.facilitator.verify_permissions(\n    payment_required=payment_required,\n    x402_access_token=access_token,\n    max_amount=\"1\"  # Optional: max credits to verify\n)\n\nif verification.is_valid:\n    print(\"Request is valid!\")\n    print(f\"Subscriber: {verification.subscriber_address}\")\nelse:\n    print(f\"Invalid request: {verification.error}\")\n</code></pre>"},{"location":"api/08-validation-of-requests/#settle-permissions","title":"Settle Permissions","text":"<p>After successfully processing a request, burn the credits:</p> <pre><code>settlement = payments.facilitator.settle_permissions(\n    payment_required=payment_required,\n    x402_access_token=access_token,\n    max_amount=\"1\"  # Credits to burn\n)\n\nif settlement.success:\n    print(f\"Credits redeemed: {settlement.credits_redeemed}\")\n    print(f\"Transaction: {settlement.tx_hash}\")\n</code></pre>"},{"location":"api/08-validation-of-requests/#complete-example-flask-agent","title":"Complete Example: Flask Agent","text":"<pre><code>from flask import Flask, request, jsonify\nfrom payments_py import Payments, PaymentOptions\nfrom payments_py.x402.helpers import build_payment_required\nfrom payments_py.common.payments_error import PaymentsError\n\napp = Flask(__name__)\n\n# Initialize payments\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:agent-key\", environment=\"sandbox\")\n)\n\nAGENT_ID = \"your-agent-id\"\nPLAN_ID = \"your-plan-id\"\n\n@app.route('/api/tasks', methods=['POST'])\ndef create_task():\n    # 1. Extract x402 access token from payment-signature header\n    access_token = request.headers.get('payment-signature', '')\n    if not access_token:\n        return jsonify({'error': 'Missing payment-signature header'}), 402\n\n    # 2. Build payment required object\n    payment_required = build_payment_required(\n        plan_id=PLAN_ID,\n        endpoint=request.url,\n        agent_id=AGENT_ID,\n        http_verb=request.method\n    )\n\n    try:\n        # 3. Verify permissions\n        verification = payments.facilitator.verify_permissions(\n            payment_required=payment_required,\n            x402_access_token=access_token,\n            max_amount=\"1\"\n        )\n\n        if not verification.is_valid:\n            return jsonify({\n                'error': 'Payment verification failed',\n                'details': verification.error\n            }), 402\n\n        # 4. Process the request\n        task_data = request.json\n        result = process_task(task_data)\n\n        # 5. Settle (burn credits) after successful processing\n        settlement = payments.facilitator.settle_permissions(\n            payment_required=payment_required,\n            x402_access_token=access_token,\n            max_amount=\"1\"\n        )\n\n        return jsonify({\n            'result': result,\n            'credits_used': settlement.credits_redeemed\n        })\n\n    except PaymentsError as e:\n        return jsonify({'error': str(e)}), 402\n\ndef process_task(data):\n    # Your AI logic here\n    return {\"status\": \"completed\", \"output\": \"Task result\"}\n\nif __name__ == '__main__':\n    app.run(port=8080)\n</code></pre>"},{"location":"api/08-validation-of-requests/#fastapi-example-with-manual-validation","title":"FastAPI Example with Manual Validation","text":"<pre><code>from fastapi import FastAPI, Request, HTTPException\nfrom payments_py import Payments, PaymentOptions\nfrom payments_py.x402.helpers import build_payment_required\n\napp = FastAPI()\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:agent-key\", environment=\"sandbox\")\n)\n\nAGENT_ID = \"your-agent-id\"\nPLAN_ID = \"your-plan-id\"\n\nasync def validate_payment(request: Request) -&gt; dict:\n    \"\"\"Validate payment and return verification result.\"\"\"\n    # Extract x402 token from payment-signature header\n    access_token = request.headers.get('payment-signature', '')\n    if not access_token:\n        raise HTTPException(status_code=402, detail=\"Missing payment-signature header\")\n\n    payment_required = build_payment_required(\n        plan_id=PLAN_ID,\n        endpoint=str(request.url),\n        agent_id=AGENT_ID,\n        http_verb=request.method\n    )\n\n    verification = payments.facilitator.verify_permissions(\n        payment_required=payment_required,\n        x402_access_token=access_token,\n        max_amount=\"1\"\n    )\n\n    if not verification.is_valid:\n        raise HTTPException(status_code=402, detail=\"Payment verification failed\")\n\n    return {\n        \"access_token\": access_token,\n        \"payment_required\": payment_required,\n        \"verification\": verification\n    }\n\n@app.post(\"/api/tasks\")\nasync def create_task(request: Request, body: dict):\n    # Validate payment\n    payment_info = await validate_payment(request)\n\n    # Process task\n    result = {\"output\": f\"Processed: {body}\"}\n\n    # Settle credits\n    settlement = payments.facilitator.settle_permissions(\n        payment_required=payment_info[\"payment_required\"],\n        x402_access_token=payment_info[\"access_token\"],\n        max_amount=\"1\"\n    )\n\n    return {\n        \"result\": result,\n        \"credits_used\": settlement.credits_redeemed\n    }\n</code></pre>"},{"location":"api/08-validation-of-requests/#using-x402-fastapi-middleware","title":"Using x402 FastAPI Middleware","text":"<p>For FastAPI applications, use the built-in x402 middleware:</p> <pre><code>from fastapi import FastAPI\nfrom payments_py.x402.fastapi import X402Middleware\n\napp = FastAPI()\n\n# Add x402 middleware\napp.add_middleware(\n    X402Middleware,\n    nvm_api_key=\"nvm:agent-key\",\n    environment=\"sandbox\",\n    agent_id=\"your-agent-id\",\n    plan_id=\"your-plan-id\"\n)\n\n@app.post(\"/api/tasks\")\nasync def create_task(body: dict):\n    # Middleware handles verification automatically\n    # Just process the request\n    return {\"result\": \"Task completed\"}\n</code></pre>"},{"location":"api/08-validation-of-requests/#verification-response","title":"Verification Response","text":"<p>The <code>verify_permissions</code> method returns:</p> Field Type Description <code>is_valid</code> <code>bool</code> Whether the request is authorized <code>subscriber_address</code> <code>str</code> Subscriber's wallet address <code>plan_id</code> <code>str</code> Plan being used <code>balance</code> <code>int</code> Current credit balance <code>error</code> <code>str</code> Error message if invalid"},{"location":"api/08-validation-of-requests/#settlement-response","title":"Settlement Response","text":"<p>The <code>settle_permissions</code> method returns:</p> Field Type Description <code>success</code> <code>bool</code> Whether settlement succeeded <code>credits_redeemed</code> <code>int</code> Number of credits burned <code>tx_hash</code> <code>str</code> Blockchain transaction hash <code>remaining_balance</code> <code>int</code> Credits remaining"},{"location":"api/08-validation-of-requests/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always verify before processing: Don't process expensive operations without verification</p> </li> <li> <p>Handle errors gracefully: Return 402 Payment Required with helpful error messages</p> </li> <li> <p>Settle after completion: Only burn credits after successfully completing the request</p> </li> <li> <p>Log transactions: Keep records of verification and settlement for debugging</p> </li> <li> <p>Use middleware for consistency: Apply validation uniformly across all endpoints</p> </li> </ol>"},{"location":"api/08-validation-of-requests/#next-steps","title":"Next Steps","text":"<ul> <li>MCP Integration - Build MCP servers with payment validation</li> <li>x402 Protocol - Deep dive into x402 protocol</li> </ul>"},{"location":"api/09-mcp-integration/","title":"MCP Integration","text":"<p>This guide explains how to integrate the Nevermined Payments Python SDK with MCP (Model Context Protocol) servers.</p>"},{"location":"api/09-mcp-integration/#overview","title":"Overview","text":"<p>MCP (Model Context Protocol) enables AI applications to interact with external tools, resources, and prompts. The Nevermined SDK provides built-in MCP integration to:</p> <ul> <li>Protect tools, resources, and prompts with paywalls</li> <li>Handle OAuth 2.1 authentication</li> <li>Manage credit consumption per operation</li> </ul>"},{"location":"api/09-mcp-integration/#mcp-integration-api","title":"MCP Integration API","text":"<p>Access the MCP integration through <code>payments.mcp</code>:</p> <pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\n# MCP integration is available as:\nmcp = payments.mcp\n</code></pre>"},{"location":"api/09-mcp-integration/#simplified-api-recommended","title":"Simplified API (Recommended)","text":"<p>The simplified API handles server setup automatically:</p>"},{"location":"api/09-mcp-integration/#register-a-tool","title":"Register a Tool","text":"<pre><code>async def hello_handler(args, context=None):\n    \"\"\"Handle the hello tool request.\"\"\"\n    name = args.get(\"name\", \"World\")\n    return {\n        \"content\": [{\"type\": \"text\", \"text\": f\"Hello, {name}!\"}]\n    }\n\n# Register the tool\npayments.mcp.register_tool(\n    name=\"hello_world\",\n    config={\n        \"description\": \"Says hello to someone\",\n        \"inputSchema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"name\": {\"type\": \"string\", \"description\": \"Name to greet\"}\n            }\n        }\n    },\n    handler=hello_handler,\n    options={\"credits\": 1}  # Cost: 1 credit per call\n)\n</code></pre>"},{"location":"api/09-mcp-integration/#register-a-resource","title":"Register a Resource","text":"<pre><code>async def config_handler(uri, variables, context=None):\n    \"\"\"Handle the configuration resource request.\"\"\"\n    return {\n        \"contents\": [{\n            \"uri\": str(uri),\n            \"mimeType\": \"application/json\",\n            \"text\": '{\"version\": \"1.0.0\", \"feature_flags\": {\"beta\": true}}'\n        }]\n    }\n\npayments.mcp.register_resource(\n    uri=\"data://config\",\n    config={\n        \"name\": \"Configuration\",\n        \"description\": \"Application configuration\",\n        \"mimeType\": \"application/json\"\n    },\n    handler=config_handler,\n    options={\"credits\": 2}  # Cost: 2 credits per access\n)\n</code></pre>"},{"location":"api/09-mcp-integration/#register-a-prompt","title":"Register a Prompt","text":"<pre><code>async def greeting_handler(args, context=None):\n    \"\"\"Handle the greeting prompt request.\"\"\"\n    style = args.get(\"style\", \"formal\")\n    return {\n        \"messages\": [{\n            \"role\": \"user\",\n            \"content\": {\n                \"type\": \"text\",\n                \"text\": f\"Please greet me in a {style} way.\"\n            }\n        }]\n    }\n\npayments.mcp.register_prompt(\n    name=\"greeting\",\n    config={\n        \"name\": \"Greeting\",\n        \"description\": \"Generates a greeting\"\n    },\n    handler=greeting_handler,\n    options={\"credits\": 1}\n)\n</code></pre>"},{"location":"api/09-mcp-integration/#start-the-server","title":"Start the Server","text":"<pre><code>import asyncio\n\nasync def main():\n    # Register handlers first\n    payments.mcp.register_tool(\"hello\", {...}, hello_handler)\n\n    # Start the MCP server\n    result = await payments.mcp.start({\n        \"port\": 5001,\n        \"agentId\": \"your-agent-id\",\n        \"serverName\": \"my-mcp-server\",\n        \"version\": \"1.0.0\",\n        \"description\": \"My MCP server with Nevermined payments\"\n    })\n\n    print(f\"Server running at: {result['info']['baseUrl']}\")\n    print(f\"Tools: {result['info']['tools']}\")\n\n    # Server runs until stopped\n    # To stop: await payments.mcp.stop()\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/09-mcp-integration/#advanced-api","title":"Advanced API","text":"<p>For more control, use the advanced API:</p>"},{"location":"api/09-mcp-integration/#configure-and-protect-handlers","title":"Configure and Protect Handlers","text":"<pre><code># Configure shared options\npayments.mcp.configure({\n    \"agentId\": \"your-agent-id\",\n    \"serverName\": \"my-mcp-server\"\n})\n\n# Wrap a handler with paywall\nasync def my_handler(args):\n    return {\"result\": \"processed\"}\n\nprotected_handler = payments.mcp.with_paywall(\n    handler=my_handler,\n    options={\n        \"kind\": \"tool\",\n        \"name\": \"my_tool\",\n        \"credits\": 1\n    }\n)\n</code></pre>"},{"location":"api/09-mcp-integration/#attach-to-existing-server","title":"Attach to Existing Server","text":"<pre><code>from mcp.server import MCPServer\n\n# Create your own MCP server\nserver = MCPServer()\n\n# Attach payments integration\nregistrar = payments.mcp.attach(server)\n\n# Register protected handlers\nregistrar.register_tool(\n    name=\"hello\",\n    config={\"description\": \"Hello tool\"},\n    handler=hello_handler,\n    options={\"credits\": 1}\n)\n\nregistrar.register_resource(\n    name=\"config\",\n    template=\"data://{path}\",\n    config={\"name\": \"Config\"},\n    handler=config_handler,\n    options={\"credits\": 2}\n)\n</code></pre>"},{"location":"api/09-mcp-integration/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom payments_py import Payments, PaymentOptions\n\n# Initialize payments\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\n# Define handlers\nasync def analyze_code(args, context=None):\n    \"\"\"Analyze code for issues.\"\"\"\n    code = args.get(\"code\", \"\")\n    language = args.get(\"language\", \"python\")\n\n    # Your analysis logic here\n    issues = analyze(code, language)\n\n    return {\n        \"content\": [{\n            \"type\": \"text\",\n            \"text\": f\"Found {len(issues)} issues in {language} code.\"\n        }]\n    }\n\nasync def get_docs(uri, variables, context=None):\n    \"\"\"Return documentation.\"\"\"\n    topic = variables.get(\"topic\", \"general\")\n\n    return {\n        \"contents\": [{\n            \"uri\": str(uri),\n            \"mimeType\": \"text/markdown\",\n            \"text\": f\"# Documentation for {topic}\\n\\nContent here...\"\n        }]\n    }\n\nasync def code_review_prompt(args, context=None):\n    \"\"\"Generate code review prompt.\"\"\"\n    return {\n        \"messages\": [{\n            \"role\": \"user\",\n            \"content\": {\n                \"type\": \"text\",\n                \"text\": \"Please review the following code for best practices...\"\n            }\n        }]\n    }\n\n# Register handlers\npayments.mcp.register_tool(\n    \"analyze_code\",\n    {\n        \"description\": \"Analyzes code for potential issues\",\n        \"inputSchema\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"code\": {\"type\": \"string\"},\n                \"language\": {\"type\": \"string\", \"default\": \"python\"}\n            },\n            \"required\": [\"code\"]\n        }\n    },\n    analyze_code,\n    {\"credits\": 5}  # 5 credits per analysis\n)\n\npayments.mcp.register_resource(\n    \"docs://{topic}\",\n    {\n        \"name\": \"Documentation\",\n        \"description\": \"Technical documentation\",\n        \"mimeType\": \"text/markdown\"\n    },\n    get_docs,\n    {\"credits\": 1}\n)\n\npayments.mcp.register_prompt(\n    \"code_review\",\n    {\n        \"name\": \"Code Review\",\n        \"description\": \"Generates a code review prompt\"\n    },\n    code_review_prompt,\n    {\"credits\": 2}\n)\n\n# Start server\nasync def main():\n    result = await payments.mcp.start({\n        \"port\": 5001,\n        \"agentId\": \"agent-123\",\n        \"serverName\": \"code-assistant-mcp\",\n        \"version\": \"1.0.0\"\n    })\n\n    print(f\"MCP Server running at {result['info']['baseUrl']}\")\n    print(f\"Tools: {result['info']['tools']}\")\n    print(f\"Resources: {result['info']['resources']}\")\n    print(f\"Prompts: {result['info']['prompts']}\")\n\n    # Keep running\n    try:\n        while True:\n            await asyncio.sleep(1)\n    except KeyboardInterrupt:\n        await payments.mcp.stop()\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/09-mcp-integration/#server-configuration","title":"Server Configuration","text":"Option Type Required Description <code>port</code> <code>int</code> Yes Server port <code>agentId</code> <code>str</code> Yes Nevermined agent DID <code>serverName</code> <code>str</code> Yes Human-readable name <code>baseUrl</code> <code>str</code> No Base URL (default: localhost) <code>version</code> <code>str</code> No Server version <code>description</code> <code>str</code> No Server description"},{"location":"api/09-mcp-integration/#handler-options","title":"Handler Options","text":"Option Type Description <code>credits</code> <code>int</code> or <code>callable</code> Credits to consume per call <code>planId</code> <code>str</code> Optional override for the plan ID (otherwise inferred from token) <code>maxAmount</code> <code>int</code> Max credits to verify during authentication (default: <code>1</code>) <code>onRedeemError</code> <code>str</code> <code>\"ignore\"</code> (default) or <code>\"propagate\"</code> to raise on redemption failure"},{"location":"api/09-mcp-integration/#response-metadata-_meta","title":"Response Metadata (<code>_meta</code>)","text":"<p>After each paywall-protected call, the SDK injects a <code>_meta</code> field into the response following the MCP specification. This field is always present regardless of whether credit redemption succeeded or failed:</p> <pre><code># Successful redemption\n{\n    \"content\": [{\"type\": \"text\", \"text\": \"result\"}],\n    \"_meta\": {\n        \"success\": True,\n        \"txHash\": \"0xabc...\",\n        \"creditsRedeemed\": \"5\",\n        \"planId\": \"plan-123\",\n        \"subscriberAddress\": \"0x123...\"\n    }\n}\n\n# Failed redemption\n{\n    \"content\": [{\"type\": \"text\", \"text\": \"result\"}],\n    \"_meta\": {\n        \"success\": False,\n        \"creditsRedeemed\": \"0\",\n        \"planId\": \"plan-123\",\n        \"subscriberAddress\": \"0x123...\",\n        \"errorReason\": \"Insufficient credits\"\n    }\n}\n</code></pre> Field Type Description <code>success</code> <code>bool</code> Whether credit redemption succeeded <code>txHash</code> <code>str</code> or <code>None</code> Blockchain transaction hash (only on success) <code>creditsRedeemed</code> <code>str</code> Number of credits burned (<code>\"0\"</code> on failure) <code>planId</code> <code>str</code> Plan used for the operation <code>subscriberAddress</code> <code>str</code> Subscriber's wallet address <code>errorReason</code> <code>str</code> Error message (only on failure)"},{"location":"api/09-mcp-integration/#endpoints","title":"Endpoints","text":"<p>The MCP server exposes:</p> <ul> <li><code>/.well-known/oauth-authorization-server</code> - OAuth 2.1 discovery</li> <li><code>/.well-known/oauth-protected-resource</code> - Resource metadata</li> <li><code>/register</code> - Client registration</li> <li><code>/mcp</code> - MCP protocol endpoint (POST/GET/DELETE)</li> <li><code>/health</code> - Health check</li> </ul>"},{"location":"api/09-mcp-integration/#next-steps","title":"Next Steps","text":"<ul> <li>A2A Integration - Agent-to-Agent protocol</li> <li>x402 Protocol - Payment protocol details</li> </ul>"},{"location":"api/10-a2a-integration/","title":"A2A Integration","text":"<p>This guide explains how to integrate the Nevermined Payments Python SDK with A2A (Agent-to-Agent) protocol servers.</p>"},{"location":"api/10-a2a-integration/#overview","title":"Overview","text":"<p>A2A (Agent-to-Agent) is a protocol that enables AI agents to communicate with each other using JSON-RPC. The Nevermined SDK provides A2A integration to:</p> <ul> <li>Build A2A servers with payment validation</li> <li>Automatically verify x402 tokens on incoming requests</li> <li>Handle credit redemption for agent tasks</li> </ul>"},{"location":"api/10-a2a-integration/#building-agent-cards","title":"Building Agent Cards","text":""},{"location":"api/10-a2a-integration/#with-a-single-plan","title":"With a Single Plan","text":"<pre><code>from payments_py.a2a.agent_card import build_payment_agent_card\n\nagent_card = build_payment_agent_card(\n    base_card={\n        \"name\": \"Code Review Agent\",\n        \"description\": \"Automated code review powered by AI\",\n        \"url\": \"https://localhost:8080\",\n        \"version\": \"1.0.0\",\n        \"capabilities\": {\n            \"streaming\": False,\n            \"pushNotifications\": False,\n        },\n    },\n    payment_metadata={\n        \"paymentType\": \"fixed\",\n        \"credits\": 1,\n        \"agentId\": \"your-agent-id\",\n        \"planId\": \"your-plan-id\",\n        \"costDescription\": \"1 credit per review\",\n    },\n)\n</code></pre>"},{"location":"api/10-a2a-integration/#with-multiple-plans","title":"With Multiple Plans","text":"<p>When your agent supports multiple plans (e.g. a basic and a premium tier), use <code>planIds</code> instead of <code>planId</code>:</p> <pre><code>agent_card = build_payment_agent_card(\n    base_card={\n        \"name\": \"Code Review Agent\",\n        \"url\": \"https://localhost:8080\",\n        \"version\": \"1.0.0\",\n        \"capabilities\": {},\n    },\n    payment_metadata={\n        \"paymentType\": \"dynamic\",\n        \"credits\": 5,\n        \"agentId\": \"your-agent-id\",\n        \"planIds\": [\"plan-basic\", \"plan-premium\"],\n        \"costDescription\": \"1-5 credits depending on review depth\",\n    },\n)\n</code></pre> <p>Note: Provide either <code>planId</code> or <code>planIds</code>, not both. <code>planIds</code> must be a non-empty list.</p>"},{"location":"api/10-a2a-integration/#agent-card-structure","title":"Agent Card Structure","text":"<p>The agent card includes a payment extension:</p> <pre><code>{\n  \"name\": \"Code Review Agent\",\n  \"url\": \"https://localhost:8080\",\n  \"version\": \"1.0.0\",\n  \"capabilities\": {\n    \"extensions\": [\n      {\n        \"uri\": \"urn:nevermined:payment\",\n        \"params\": {\n          \"paymentType\": \"dynamic\",\n          \"credits\": 5,\n          \"agentId\": \"your-agent-id\",\n          \"planIds\": [\"plan-basic\", \"plan-premium\"],\n          \"costDescription\": \"1-5 credits depending on review depth\"\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"api/10-a2a-integration/#using-the-a2a_requires_payment-decorator","title":"Using the <code>@a2a_requires_payment</code> Decorator","text":"<p>The simplest way to create a payment-protected A2A agent:</p> <pre><code>from payments_py import Payments\nfrom payments_py.common.types import PaymentOptions\nfrom payments_py.a2a import AgentResponse, a2a_requires_payment, build_payment_agent_card\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:your-key\", environment=\"sandbox\")\n)\n\nagent_card = build_payment_agent_card(\n    base_card={\n        \"name\": \"My Agent\",\n        \"url\": \"http://localhost:8080\",\n        \"version\": \"1.0.0\",\n        \"capabilities\": {},\n    },\n    payment_metadata={\n        \"paymentType\": \"dynamic\",\n        \"credits\": 3,\n        \"agentId\": \"your-agent-id\",\n        \"planIds\": [\"plan-1\", \"plan-2\"],\n    },\n)\n\n@a2a_requires_payment(\n    payments=payments,\n    agent_card=agent_card,\n    default_credits=1,\n)\nasync def my_agent(context) -&gt; AgentResponse:\n    text = context.get_user_input()\n    return AgentResponse(text=f\"Echo: {text}\", credits_used=1)\n\n# Start serving (blocking)\nmy_agent.serve(port=8080)\n</code></pre> <p>The decorator handles:</p> <ul> <li>Payment middleware (verify/settle) automatically</li> <li>Publishing task status events with <code>creditsUsed</code> metadata</li> <li>Credit burning on task completion</li> </ul>"},{"location":"api/10-a2a-integration/#agentresponse","title":"<code>AgentResponse</code>","text":"Field Type Description <code>text</code> <code>str</code> The agent's text response <code>credits_used</code> <code>int \\| None</code> Credits consumed (falls back to <code>default_credits</code>) <code>metadata</code> <code>dict \\| None</code> Extra metadata for the final event"},{"location":"api/10-a2a-integration/#starting-an-a2a-server-advanced","title":"Starting an A2A Server (Advanced)","text":"<p>For more control, use <code>PaymentsA2AServer.start()</code> directly:</p> <pre><code>from payments_py.a2a.server import PaymentsA2AServer\nfrom a2a.server.agent_execution import AgentExecutor\nfrom a2a.server.events.event_queue import EventQueue\n\nclass MyExecutor(AgentExecutor):\n    async def execute(self, context, event_queue: EventQueue):\n        # Your agent logic \u2014 publish events to event_queue\n        ...\n\n    async def cancel(self, context, event_queue: EventQueue):\n        ...\n\nresult = PaymentsA2AServer.start(\n    agent_card=agent_card,\n    executor=MyExecutor(),\n    payments_service=payments,\n    port=8080,\n    base_path=\"/\",\n    expose_agent_card=True,\n    async_execution=False,\n)\n\n# Run the server\nimport asyncio\nasyncio.run(result.server.serve())\n</code></pre>"},{"location":"api/10-a2a-integration/#server-configuration-options","title":"Server Configuration Options","text":"Option Type Required Description <code>agent_card</code> <code>AgentCard</code> Yes A2A agent card with payment extension <code>executor</code> <code>AgentExecutor</code> Yes Your agent implementation <code>payments_service</code> <code>Payments</code> Yes Payments instance <code>port</code> <code>int</code> No Server port (default: 8080) <code>task_store</code> <code>TaskStore</code> No Task storage implementation <code>base_path</code> <code>str</code> No Base URL path (default: \"/\") <code>expose_agent_card</code> <code>bool</code> No Expose /.well-known/agent.json <code>hooks</code> <code>dict</code> No Request lifecycle hooks <code>async_execution</code> <code>bool</code> No Enable async task execution"},{"location":"api/10-a2a-integration/#request-validation","title":"Request Validation","text":"<p>The A2A server automatically validates payments on every POST request:</p> <ol> <li>Extracts Bearer token from Authorization header</li> <li>Reads <code>planId</code> or <code>planIds</code> from the agent card's payment extension</li> <li>Verifies permissions via <code>build_payment_required_for_plans()</code></li> <li>Rejects requests with 402 if validation fails, including a base64-encoded <code>payment-required</code> header</li> </ol> <p>When multiple plans are configured, the 402 response includes all plans in <code>accepts[]</code>, allowing the client to choose which plan to purchase.</p> <pre><code>HTTP/1.1 402 Payment Required\npayment-required: eyJ4NDAy... (base64-encoded X402PaymentRequired)\n\n{\"error\": {\"code\": -32001, \"message\": \"Missing bearer token.\"}}\n</code></pre>"},{"location":"api/10-a2a-integration/#client-usage","title":"Client Usage","text":""},{"location":"api/10-a2a-integration/#discovering-plans-from-the-agent-card","title":"Discovering Plans from the Agent Card","text":"<p>Consumers can fetch the agent card to discover available plans:</p> <pre><code>import httpx\n\nasync with httpx.AsyncClient() as client:\n    resp = await client.get(\"http://agent-url/.well-known/agent.json\")\n    card = resp.json()\n\nextensions = card[\"capabilities\"][\"extensions\"]\npayment_ext = next(e for e in extensions if e[\"uri\"] == \"urn:nevermined:payment\")\nplan_ids = payment_ext[\"params\"].get(\"planIds\") or [payment_ext[\"params\"][\"planId\"]]\nagent_id = payment_ext[\"params\"][\"agentId\"]\n</code></pre>"},{"location":"api/10-a2a-integration/#ordering-a-plan-and-sending-messages","title":"Ordering a Plan and Sending Messages","text":"<pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n)\n\n# Order (purchase) the plan\npayments.plans.order_plan(plan_ids[0])\n\n# Get x402 access token\ntoken_resp = payments.x402.get_x402_access_token(\n    plan_id=plan_ids[0],\n    agent_id=agent_id,\n)\naccess_token = token_resp[\"accessToken\"]\n\n# Send A2A JSON-RPC message\nasync with httpx.AsyncClient() as client:\n    resp = await client.post(\n        \"http://agent-url/\",\n        json={\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"message/send\",\n            \"params\": {\n                \"message\": {\n                    \"messageId\": \"msg-1\",\n                    \"role\": \"user\",\n                    \"parts\": [{\"kind\": \"text\", \"text\": \"Review this code\"}],\n                }\n            },\n        },\n        headers={\"Authorization\": f\"Bearer {access_token}\"},\n    )\n    result = resp.json()\n</code></pre>"},{"location":"api/10-a2a-integration/#hooks","title":"Hooks","text":"<p>Add custom logic at request lifecycle points:</p> <pre><code>async def before_request(method, params, request):\n    print(f\"Incoming request: {method}\")\n\nasync def after_request(method, response, request):\n    print(f\"Request completed: {method}\")\n\nasync def on_error(method, error, request):\n    print(f\"Request failed: {method} - {error}\")\n\nresult = PaymentsA2AServer.start(\n    agent_card=agent_card,\n    executor=executor,\n    payments_service=payments,\n    hooks={\n        \"beforeRequest\": before_request,\n        \"afterRequest\": after_request,\n        \"onError\": on_error,\n    },\n)\n</code></pre>"},{"location":"api/10-a2a-integration/#error-handling","title":"Error Handling","text":"Error Code HTTP Status Description -32001 402 Missing Bearer token -32001 402 Payment validation failed -32001 402 Agent ID missing from card -32001 402 Plan ID missing from card"},{"location":"api/10-a2a-integration/#next-steps","title":"Next Steps","text":"<ul> <li>x402 Protocol - Deep dive into x402 payment protocol</li> <li>Request Validation - Manual validation patterns</li> </ul>"},{"location":"api/11-x402/","title":"x402 Protocol","text":"<p>This guide covers the x402 payment protocol for verifying permissions and settling payments.</p>"},{"location":"api/11-x402/#overview","title":"Overview","text":"<p>x402 is a payment protocol that enables:</p> <ul> <li>Permission Generation: Subscribers create access tokens for agents</li> <li>Permission Verification: Agents verify tokens without burning credits</li> <li>Permission Settlement: Agents burn credits after completing work</li> </ul> <p>The protocol is named after HTTP status code 402 (Payment Required).</p>"},{"location":"api/11-x402/#generate-payment-permissions","title":"Generate Payment Permissions","text":""},{"location":"api/11-x402/#from-nevermined-app","title":"From Nevermined App","text":"<p>The easiest way to generate permissions is through the Nevermined App Permissions page:</p> <ol> <li>Navigate to the permissions page</li> <li>Select your plan and agent</li> <li>Configure limits (optional)</li> <li>Generate the access token</li> </ol>"},{"location":"api/11-x402/#from-sdk","title":"From SDK","text":"<pre><code>from payments_py import Payments, PaymentOptions\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n)\n\n# Basic token generation\nresult = payments.x402.get_x402_access_token(\n    plan_id=\"your-plan-id\",\n    agent_id=\"agent-id\"\n)\naccess_token = result['accessToken']\n\n# Advanced: with limits\nresult = payments.x402.get_x402_access_token(\n    plan_id=\"your-plan-id\",\n    agent_id=\"agent-id\",\n    redemption_limit=100,  # Max 100 requests\n    order_limit=\"1000000000000000000\",  # Max 1 token spend\n    expiration=\"2025-12-31T23:59:59Z\"  # Expires end of year\n)\n</code></pre>"},{"location":"api/11-x402/#token-structure","title":"Token Structure","text":"<p>The x402 token is a base64-encoded JSON document:</p> <pre><code>{\n  \"payload\": {\n    \"authorization\": {\n      \"from\": \"0xSubscriberAddress\",\n      \"planId\": \"plan-123\",\n      \"agentId\": \"agent-456\"\n    },\n    \"sessionKey\": {\n      \"address\": \"0xSessionKeyAddress\",\n      \"permissions\": [\"order\", \"burn\"],\n      \"limits\": {\n        \"redemptionLimit\": 100,\n        \"orderLimit\": \"1000000000000000000\"\n      }\n    }\n  },\n  \"signature\": \"0x...\"\n}\n</code></pre>"},{"location":"api/11-x402/#verify-payment-permissions","title":"Verify Payment Permissions","text":"<p>Verification checks if a subscriber has valid permissions without burning credits:</p> <pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.x402.helpers import build_payment_required\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:agent-key\", environment=\"sandbox\")\n)\n\n# Build the 402 Payment Required specification\npayment_required = build_payment_required(\n    plan_id=\"your-plan-id\",\n    endpoint=\"https://your-api.com/endpoint\",\n    agent_id=\"your-agent-id\",\n    http_verb=\"POST\"\n)\n\n# Verify the token\nverification = payments.facilitator.verify_permissions(\n    payment_required=payment_required,\n    x402_access_token=access_token,\n    max_amount=\"1\"  # Optional: max credits to verify\n)\n\nif verification.is_valid:\n    print(f\"Valid! Subscriber: {verification.subscriber_address}\")\n    print(f\"Balance: {verification.balance}\")\nelse:\n    print(f\"Invalid: {verification.error}\")\n</code></pre>"},{"location":"api/11-x402/#verification-response","title":"Verification Response","text":"Field Type Description <code>is_valid</code> <code>bool</code> Whether verification passed <code>subscriber_address</code> <code>str</code> Subscriber's wallet address <code>plan_id</code> <code>str</code> Plan being used <code>balance</code> <code>int</code> Current credit balance <code>error</code> <code>str</code> Error message if invalid"},{"location":"api/11-x402/#settle-payment-permissions","title":"Settle Payment Permissions","text":"<p>Settlement burns credits after successfully processing a request:</p> <pre><code># After processing the request successfully\nsettlement = payments.facilitator.settle_permissions(\n    payment_required=payment_required,\n    x402_access_token=access_token,\n    max_amount=\"1\",  # Credits to burn\n    agent_request_id=\"request-123\"  # Optional: for tracking\n)\n\nif settlement.success:\n    print(f\"Settled! Credits burned: {settlement.credits_redeemed}\")\n    print(f\"Transaction: {settlement.tx_hash}\")\n    print(f\"Remaining: {settlement.remaining_balance}\")\nelse:\n    print(f\"Settlement failed: {settlement.error}\")\n</code></pre>"},{"location":"api/11-x402/#settlement-response","title":"Settlement Response","text":"Field Type Description <code>success</code> <code>bool</code> Whether settlement succeeded <code>credits_redeemed</code> <code>int</code> Credits that were burned <code>tx_hash</code> <code>str</code> Blockchain transaction hash <code>remaining_balance</code> <code>int</code> Credits remaining"},{"location":"api/11-x402/#payment-required-object","title":"Payment Required Object","text":"<p>The <code>X402PaymentRequired</code> object specifies what payment is required:</p> <pre><code>from payments_py.x402.types import X402PaymentRequired, X402Scheme\n\npayment_required = X402PaymentRequired(\n    x402_version=2,\n    accepts=[\n        X402Scheme(\n            scheme=\"nvm:erc4337\",\n            network=\"eip155:84532\",  # Base Sepolia\n            plan_id=\"your-plan-id\"\n        )\n    ],\n    extensions={}\n)\n</code></pre>"},{"location":"api/11-x402/#using-the-helpers","title":"Using the Helpers","text":"<pre><code>from payments_py.x402.helpers import build_payment_required, build_payment_required_for_plans\n\n# Single plan\npayment_required = build_payment_required(\n    plan_id=\"your-plan-id\",\n    endpoint=\"https://api.example.com/tasks\",\n    agent_id=\"agent-123\",\n    http_verb=\"POST\"\n)\n\n# Multiple plans \u2014 creates one entry per plan in accepts[]\npayment_required = build_payment_required_for_plans(\n    plan_ids=[\"plan-basic\", \"plan-premium\"],\n    endpoint=\"https://api.example.com/tasks\",\n    agent_id=\"agent-123\",\n    http_verb=\"POST\"\n)\n</code></pre> <p>For a single plan, <code>build_payment_required_for_plans</code> delegates to <code>build_payment_required</code> internally.</p>"},{"location":"api/11-x402/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.x402.helpers import build_payment_required\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n# Agent's payments instance\nagent_payments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:agent-key\", environment=\"sandbox\")\n)\n\nPLAN_ID = \"your-plan-id\"\nAGENT_ID = \"your-agent-id\"\n\n@app.route('/api/process', methods=['POST'])\ndef process_request():\n    # 1. Extract x402 token from payment-signature header\n    token = request.headers.get('payment-signature', '')\n    if not token:\n        return jsonify({'error': 'Missing payment-signature header'}), 402\n\n    # 2. Build payment requirement\n    payment_required = build_payment_required(\n        plan_id=PLAN_ID,\n        endpoint=request.url,\n        agent_id=AGENT_ID,\n        http_verb=request.method\n    )\n\n    # 3. Verify (doesn't burn credits)\n    verification = agent_payments.facilitator.verify_permissions(\n        payment_required=payment_required,\n        x402_access_token=token,\n        max_amount=\"1\"\n    )\n\n    if not verification.is_valid:\n        return jsonify({\n            'error': 'Payment required',\n            'details': verification.error,\n            'paymentRequired': payment_required.model_dump()\n        }), 402\n\n    # 4. Process the request\n    try:\n        result = do_expensive_work(request.json)\n    except Exception as e:\n        # Don't settle on failure\n        return jsonify({'error': str(e)}), 500\n\n    # 5. Settle (burn credits) on success\n    settlement = agent_payments.facilitator.settle_permissions(\n        payment_required=payment_required,\n        x402_access_token=token,\n        max_amount=\"1\"\n    )\n\n    return jsonify({\n        'result': result,\n        'creditsUsed': settlement.credits_redeemed,\n        'remainingBalance': settlement.remaining_balance\n    })\n\ndef do_expensive_work(data):\n    # Your processing logic\n    return {'processed': True}\n\nif __name__ == '__main__':\n    app.run(port=8080)\n</code></pre>"},{"location":"api/11-x402/#http-flow","title":"HTTP Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Subscriber \u2502                  \u2502    Agent    \u2502                  \u2502  Nevermined \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                \u2502                                \u2502\n       \u2502 GET /api/process               \u2502                                \u2502\n       \u2502 (no token)                     \u2502                                \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502                                \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502                                \u2502\n       \u2502 402 Payment Required           \u2502                                \u2502\n       \u2502 {paymentRequired: {...}}       \u2502                                \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502 get_x402_access_token()        \u2502                                \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n       \u2502 {accessToken: \"...\"}           \u2502                                \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502 GET /api/process               \u2502                                \u2502\n       \u2502 payment-signature: &lt;token&gt;     \u2502                                \u2502\n       \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502                                \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502                                \u2502 verify_permissions()           \u2502\n       \u2502                                \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502                                \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n       \u2502                                \u2502 {isValid: true}                \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502                                \u2502 [process request]              \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502                                \u2502 settle_permissions()           \u2502\n       \u2502                                \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502                                \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n       \u2502                                \u2502 {success: true}                \u2502\n       \u2502                                \u2502                                \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2502                                \u2502\n       \u2502 200 OK {result: ...}           \u2502                                \u2502\n       \u2502                                \u2502                                \u2502\n</code></pre>"},{"location":"api/11-x402/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always verify before processing: Don't do expensive work without verification</p> </li> <li> <p>Only settle on success: Don't burn credits if processing fails</p> </li> <li> <p>Use agent_request_id: Include request IDs for tracking and debugging</p> </li> <li> <p>Handle 402 responses: Return proper payment required responses with scheme info</p> </li> <li> <p>Cache verifications carefully: Tokens can be used multiple times until limits are reached</p> </li> </ol>"},{"location":"api/11-x402/#error-codes","title":"Error Codes","text":"Error Description Resolution <code>invalid_token</code> Token is malformed Generate a new token <code>expired_token</code> Token has expired Generate a new token <code>insufficient_balance</code> Not enough credits Order more credits <code>invalid_plan</code> Plan ID mismatch Use correct plan ID <code>invalid_agent</code> Agent ID mismatch Use correct agent ID"},{"location":"api/11-x402/#next-steps","title":"Next Steps","text":"<ul> <li>Request Validation - More validation patterns</li> <li>MCP Integration - x402 with MCP servers</li> </ul>"},{"location":"reference/data_models/","title":"Data Models Reference","text":"<p>Type definitions and models used throughout the SDK.</p>"},{"location":"reference/data_models/#core-types","title":"Core Types","text":""},{"location":"reference/data_models/#paymentoptions","title":"PaymentOptions","text":""},{"location":"reference/data_models/#payments_py.common.types.PaymentOptions","title":"PaymentOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for initializing the Payments class.</p>"},{"location":"reference/data_models/#agentmetadata","title":"AgentMetadata","text":""},{"location":"reference/data_models/#payments_py.common.types.AgentMetadata","title":"AgentMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for an agent.</p> <p>Used when registering agents with :meth:<code>payments.agents.register_agent</code> or :meth:<code>payments.agents.register_agent_and_plan</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the agent (required)</p> <p> </p> <code>description</code> <p>A description of the agent</p> <p> </p> <code>author</code> <p>The author of the agent</p> <p> </p> <code>license</code> <p>License information</p> <p> </p> <code>tags</code> <p>List of tags for categorization</p> <p> </p> <code>integration</code> <p>Integration type</p> <p> </p> <code>sample_link</code> <p>Link to a sample/demo</p> <p> </p> <code>api_description</code> <p>Description of the API</p> <p> </p> <code>date_created</code> <p>ISO date string of creation date</p> <p> </p> <p>Example::     agent_metadata = AgentMetadata(         name=\"My AI Agent\",         description=\"A helpful AI assistant\",         tags=[\"ai\", \"assistant\"],         author=\"John Doe\"     )</p>"},{"location":"reference/data_models/#agentapiattributes","title":"AgentAPIAttributes","text":""},{"location":"reference/data_models/#payments_py.common.types.AgentAPIAttributes","title":"AgentAPIAttributes","text":"<p>               Bases: <code>BaseModel</code></p> <p>API attributes for an agent.</p> <p>Defines the API endpoints and authentication configuration for an agent. Used when registering agents with :meth:<code>payments.agents.register_agent</code> or :meth:<code>payments.agents.register_agent_and_plan</code>.</p> PARAMETER DESCRIPTION <code>endpoints</code> <p>List of endpoint dictionaries with HTTP verb as key and URL as value.       URLs can include placeholders like <code>:agentId</code> which will be replaced.</p> <p> </p> <code>open_endpoints</code> <p>List of endpoints that don't require authentication</p> <p> </p> <code>agent_definition_url</code> <p>URL to the agent definition. Can be an OpenAPI spec, MCP Manifest, or A2A agent card. This field is mandatory.</p> <p> </p> <code>auth_type</code> <p>Authentication type (default: AuthType.NONE)</p> <p> </p> <code>username</code> <p>Username for basic auth (if auth_type is BASIC)</p> <p> </p> <code>password</code> <p>Password for basic auth (if auth_type is BASIC)</p> <p> </p> <code>token</code> <p>Token for bearer auth (if auth_type is BEARER)</p> <p> </p> <code>api_key</code> <p>API key for authentication</p> <p> </p> <code>headers</code> <p>Additional headers to include in requests</p> <p> </p> <p>Example::     agent_api = AgentAPIAttributes(         endpoints=[             {\"POST\": \"https://example.com/api/v1/agents/:agentId/tasks\"},             {\"GET\": \"https://example.com/api/v1/agents/:agentId/tasks/:taskId\"}         ],         agent_definition_url=\"https://example.com/api/v1/openapi.json\",  # OpenAPI spec, MCP Manifest, or A2A agent card         auth_type=AuthType.BEARER     )</p>"},{"location":"reference/data_models/#planmetadata","title":"PlanMetadata","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanMetadata","title":"PlanMetadata","text":"<p>               Bases: <code>AgentMetadata</code></p> <p>Metadata for a payment plan, extends AgentMetadata.</p> <p>Used when registering payment plans with methods like :meth:<code>payments.plans.register_credits_plan</code>, :meth:<code>payments.plans.register_time_plan</code>, or :meth:<code>payments.agents.register_agent_and_plan</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the plan (required, inherited from AgentMetadata)</p> <p> </p> <code>description</code> <p>A description of the plan (inherited from AgentMetadata)</p> <p> </p> <code>is_trial_plan</code> <p>Whether this is a trial plan (can only be purchased once per user)</p> <p> </p> <code>All other fields from </code> <p>class:<code>AgentMetadata</code> are also available</p> <p> </p> <p>Example::     plan_metadata = PlanMetadata(         name=\"Basic Plan\",         description=\"100 credits plan\",         is_trial_plan=False     )</p> <pre><code># For trial plans\ntrial_metadata = PlanMetadata(\n    name=\"Free Trial\",\n    description=\"10 free credits\",\n    is_trial_plan=True\n)\n</code></pre>"},{"location":"reference/data_models/#planpriceconfig","title":"PlanPriceConfig","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanPriceConfig","title":"PlanPriceConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition of the price configuration for a Payment Plan.</p> <p>Use helper functions from :mod:<code>payments_py.plans</code> to create instances: - :func:<code>payments_py.plans.get_fiat_price_config</code> for fiat payments - :func:<code>payments_py.plans.get_erc20_price_config</code> for ERC20 token payments - :func:<code>payments_py.plans.get_native_token_price_config</code> for native token (ETH) payments - :func:<code>payments_py.plans.get_free_price_config</code> for free plans</p> PARAMETER DESCRIPTION <code>token_address</code> <p>Address of the ERC20 token (ZeroAddress for native token or fiat)</p> <p> </p> <code>amounts</code> <p>List of payment amounts in smallest unit</p> <p> </p> <code>receivers</code> <p>List of receiver addresses</p> <p> </p> <code>contract_address</code> <p>Smart contract address (usually ZeroAddress)</p> <p> </p> <code>fee_controller</code> <p>Fee controller address (usually ZeroAddress)</p> <p> </p> <code>external_price_address</code> <p>External price oracle address (usually ZeroAddress)</p> <p> </p> <code>template_address</code> <p>Template address (usually ZeroAddress)</p> <p> </p> <code>is_crypto</code> <p>Whether this is a crypto payment (False for fiat)</p> <p> </p> <p>Example::     # Don't create directly - use helper functions instead:     from payments_py.plans import get_erc20_price_config</p> <pre><code>price_config = get_erc20_price_config(20, ERC20_ADDRESS, builder_address)\n</code></pre>"},{"location":"reference/data_models/#plancreditsconfig","title":"PlanCreditsConfig","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanCreditsConfig","title":"PlanCreditsConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Definition of the credits configuration for a payment plan.</p> <p>Use helper functions from :mod:<code>payments_py.plans</code> to create instances: - :func:<code>payments_py.plans.get_fixed_credits_config</code> for fixed credits per request - :func:<code>payments_py.plans.get_dynamic_credits_config</code> for variable credits per request - :func:<code>payments_py.plans.get_expirable_duration_config</code> for time-limited plans - :func:<code>payments_py.plans.get_non_expirable_duration_config</code> for non-expiring plans</p> PARAMETER DESCRIPTION <code>is_redemption_amount_fixed</code> <p>Whether credits consumed per request is fixed (True) or variable (False)</p> <p> </p> <code>redemption_type</code> <p>Who can redeem credits (PlanRedemptionType enum)</p> <p> </p> <code>proof_required</code> <p>Whether proof is required for redemption</p> <p> </p> <code>duration_secs</code> <p>Duration in seconds (0 for non-expirable, &gt;0 for expirable)</p> <p> </p> <code>amount</code> <p>Total credits granted as string</p> <p> </p> <code>min_amount</code> <p>Minimum credits consumed per request</p> <p> </p> <code>max_amount</code> <p>Maximum credits consumed per request</p> <p> </p> <code>nft_address</code> <p>Optional NFT address</p> <p> </p> <p>Example::     # Don't create directly - use helper functions instead:     from payments_py.plans import get_fixed_credits_config, ONE_DAY_DURATION, get_expirable_duration_config</p> <pre><code># Fixed credits plan\ncredits_config = get_fixed_credits_config(100, credits_per_request=1)\n\n# Time-limited plan\ntime_config = get_expirable_duration_config(ONE_DAY_DURATION)\n</code></pre>"},{"location":"reference/data_models/#planbalance","title":"PlanBalance","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanBalance","title":"PlanBalance","text":"<p>               Bases: <code>BaseModel</code></p> <p>Balance information for a payment plan.</p>"},{"location":"reference/data_models/#enums","title":"Enums","text":""},{"location":"reference/data_models/#authtype","title":"AuthType","text":""},{"location":"reference/data_models/#payments_py.common.types.AuthType","title":"AuthType","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Allowed authentication types for AgentAPIAttributes.</p>"},{"location":"reference/data_models/#planpricetype","title":"PlanPriceType","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanPriceType","title":"PlanPriceType","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of prices that can be configured for a plan. 0 - FIXED_PRICE, 1 - FIXED_FIAT_PRICE, 2 - SMART_CONTRACT_PRICE</p>"},{"location":"reference/data_models/#plancreditstype","title":"PlanCreditsType","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanCreditsType","title":"PlanCreditsType","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of credits that can be obtained when purchasing a plan. 0 - EXPIRABLE, 1 - FIXED, 2 - DYNAMIC</p>"},{"location":"reference/data_models/#planredemptiontype","title":"PlanRedemptionType","text":""},{"location":"reference/data_models/#payments_py.common.types.PlanRedemptionType","title":"PlanRedemptionType","text":"<p>               Bases: <code>Enum</code></p> <p>Different types of redemptions criterias that can be used when redeeming credits. 0 - ONLY_GLOBAL_ROLE, 1 - ONLY_OWNER, 2 - ONLY_PLAN_ROLE, 4 - ONLY_SUBSCRIBER</p>"},{"location":"reference/data_models/#agenttaskstatus","title":"AgentTaskStatus","text":""},{"location":"reference/data_models/#payments_py.common.types.AgentTaskStatus","title":"AgentTaskStatus","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Status of an agent task.</p>"},{"location":"reference/data_models/#utility-types","title":"Utility Types","text":""},{"location":"reference/data_models/#paginationoptions","title":"PaginationOptions","text":""},{"location":"reference/data_models/#payments_py.common.types.PaginationOptions","title":"PaginationOptions","text":"<p>               Bases: <code>BaseModel</code></p> <p>Options for pagination in API requests to the Nevermined API.</p>"},{"location":"reference/data_models/#trackagentsubtaskdto","title":"TrackAgentSubTaskDto","text":""},{"location":"reference/data_models/#payments_py.common.types.TrackAgentSubTaskDto","title":"TrackAgentSubTaskDto","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data transfer object for tracking agent sub tasks.</p>"},{"location":"reference/data_models/#plan-helper-functions","title":"Plan Helper Functions","text":""},{"location":"reference/data_models/#payments_py.plans","title":"plans","text":"<p>Utility functions for creating and managing payment plans.</p>"},{"location":"reference/data_models/#payments_py.plans.get_fiat_price_config","title":"get_fiat_price_config","text":"<pre><code>get_fiat_price_config(\n    amount: int, receiver: Address\n) -&gt; PlanPriceConfig\n</code></pre> <p>Get a fixed fiat price configuration for a plan.</p> PARAMETER DESCRIPTION <code>amount</code> <p>The amount in the smallest unit of the fiat currency</p> <p> TYPE: <code>int</code> </p> <code>receiver</code> <p>The address that will receive the payment</p> <p> TYPE: <code>Address</code> </p> RETURNS DESCRIPTION <code>PlanPriceConfig</code> <p>A PlanPriceConfig object configured for fiat payments</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the receiver address is not a valid Ethereum address</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_fiat_price_config(amount: int, receiver: Address) -&gt; PlanPriceConfig:\n    \"\"\"\n    Get a fixed fiat price configuration for a plan.\n\n    Args:\n        amount: The amount in the smallest unit of the fiat currency\n        receiver: The address that will receive the payment\n\n    Returns:\n        A PlanPriceConfig object configured for fiat payments\n\n    Raises:\n        ValueError: If the receiver address is not a valid Ethereum address\n    \"\"\"\n    if not is_ethereum_address(receiver):\n        raise ValueError(f\"Receiver address {receiver} is not a valid Ethereum address\")\n    return PlanPriceConfig(\n        token_address=ZeroAddress,\n        amounts=[amount],\n        receivers=[receiver],\n        contract_address=ZeroAddress,\n        fee_controller=ZeroAddress,\n        external_price_address=ZeroAddress,\n        template_address=ZeroAddress,\n        is_crypto=False,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_erc20_price_config","title":"get_erc20_price_config","text":"<pre><code>get_erc20_price_config(\n    amount: int, token_address: Address, receiver: Address\n) -&gt; PlanPriceConfig\n</code></pre> <p>Get a fixed ERC20 token price configuration for a plan.</p> PARAMETER DESCRIPTION <code>amount</code> <p>The amount in the smallest unit of the ERC20 token</p> <p> TYPE: <code>int</code> </p> <code>token_address</code> <p>The address of the ERC20 token</p> <p> TYPE: <code>Address</code> </p> <code>receiver</code> <p>The address that will receive the payment</p> <p> TYPE: <code>Address</code> </p> RETURNS DESCRIPTION <code>PlanPriceConfig</code> <p>A PlanPriceConfig object configured for ERC20 token payments</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_erc20_price_config(\n    amount: int, token_address: Address, receiver: Address\n) -&gt; PlanPriceConfig:\n    \"\"\"\n    Get a fixed ERC20 token price configuration for a plan.\n\n    Args:\n        amount: The amount in the smallest unit of the ERC20 token\n        token_address: The address of the ERC20 token\n        receiver: The address that will receive the payment\n\n    Returns:\n        A PlanPriceConfig object configured for ERC20 token payments\n    \"\"\"\n    return get_crypto_price_config(amount, receiver, token_address)\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_native_token_price_config","title":"get_native_token_price_config","text":"<pre><code>get_native_token_price_config(\n    amount: int, receiver: Address\n) -&gt; PlanPriceConfig\n</code></pre> <p>Get a fixed native token price configuration for a plan.</p> PARAMETER DESCRIPTION <code>amount</code> <p>The amount in the smallest unit of the native token</p> <p> TYPE: <code>int</code> </p> <code>receiver</code> <p>The address that will receive the payment</p> <p> TYPE: <code>Address</code> </p> RETURNS DESCRIPTION <code>PlanPriceConfig</code> <p>A PlanPriceConfig object configured for native token payments</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_native_token_price_config(amount: int, receiver: Address) -&gt; PlanPriceConfig:\n    \"\"\"\n    Get a fixed native token price configuration for a plan.\n\n    Args:\n        amount: The amount in the smallest unit of the native token\n        receiver: The address that will receive the payment\n\n    Returns:\n        A PlanPriceConfig object configured for native token payments\n    \"\"\"\n    return get_crypto_price_config(amount, receiver, ZeroAddress)\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_crypto_price_config","title":"get_crypto_price_config","text":"<pre><code>get_crypto_price_config(\n    amount: int,\n    receiver: Address,\n    token_address: Address = ZeroAddress,\n) -&gt; PlanPriceConfig\n</code></pre> <p>Get a fixed crypto price configuration for a plan.</p> PARAMETER DESCRIPTION <code>amount</code> <p>The amount in the smallest unit of the token</p> <p> TYPE: <code>int</code> </p> <code>receiver</code> <p>The address that will receive the payment</p> <p> TYPE: <code>Address</code> </p> <code>token_address</code> <p>The address of the token to use for payment (defaults to native token)</p> <p> TYPE: <code>Address</code> DEFAULT: <code>ZeroAddress</code> </p> RETURNS DESCRIPTION <code>PlanPriceConfig</code> <p>A PlanPriceConfig object configured for crypto payments</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the receiver address is not a valid Ethereum address</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_crypto_price_config(\n    amount: int, receiver: Address, token_address: Address = ZeroAddress\n) -&gt; PlanPriceConfig:\n    \"\"\"\n    Get a fixed crypto price configuration for a plan.\n\n    Args:\n        amount: The amount in the smallest unit of the token\n        receiver: The address that will receive the payment\n        token_address: The address of the token to use for payment (defaults to native token)\n\n    Returns:\n        A PlanPriceConfig object configured for crypto payments\n\n    Raises:\n        ValueError: If the receiver address is not a valid Ethereum address\n    \"\"\"\n    if not is_ethereum_address(receiver):\n        raise ValueError(f\"Receiver address {receiver} is not a valid Ethereum address\")\n    return PlanPriceConfig(\n        token_address=token_address,\n        amounts=[amount],\n        receivers=[receiver],\n        contract_address=ZeroAddress,\n        fee_controller=ZeroAddress,\n        external_price_address=ZeroAddress,\n        template_address=ZeroAddress,\n        is_crypto=True,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_free_price_config","title":"get_free_price_config","text":"<pre><code>get_free_price_config() -&gt; PlanPriceConfig\n</code></pre> <p>Get a free price configuration for a plan.</p> RETURNS DESCRIPTION <code>PlanPriceConfig</code> <p>A PlanPriceConfig object configured for free plans</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_free_price_config() -&gt; PlanPriceConfig:\n    \"\"\"\n    Get a free price configuration for a plan.\n\n    Returns:\n        A PlanPriceConfig object configured for free plans\n    \"\"\"\n    return PlanPriceConfig(\n        token_address=ZeroAddress,\n        amounts=[],\n        receivers=[],\n        contract_address=ZeroAddress,\n        fee_controller=ZeroAddress,\n        external_price_address=ZeroAddress,\n        template_address=ZeroAddress,\n        is_crypto=True,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_fixed_credits_config","title":"get_fixed_credits_config","text":"<pre><code>get_fixed_credits_config(\n    credits_granted: int, credits_per_request: int = 1\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Get a fixed credits configuration for a plan.</p> PARAMETER DESCRIPTION <code>credits_granted</code> <p>The total number of credits granted</p> <p> TYPE: <code>int</code> </p> <code>credits_per_request</code> <p>The number of credits consumed per request (default: 1)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>PlanCreditsConfig</code> <p>A PlanCreditsConfig object configured for fixed credits</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_fixed_credits_config(\n    credits_granted: int, credits_per_request: int = 1\n) -&gt; PlanCreditsConfig:\n    \"\"\"\n    Get a fixed credits configuration for a plan.\n\n    Args:\n        credits_granted: The total number of credits granted\n        credits_per_request: The number of credits consumed per request (default: 1)\n\n    Returns:\n        A PlanCreditsConfig object configured for fixed credits\n    \"\"\"\n    return PlanCreditsConfig(\n        is_redemption_amount_fixed=True,\n        redemption_type=PlanRedemptionType.ONLY_SUBSCRIBER,\n        proof_required=False,\n        duration_secs=0,\n        amount=str(credits_granted),\n        min_amount=credits_per_request,\n        max_amount=credits_per_request,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_dynamic_credits_config","title":"get_dynamic_credits_config","text":"<pre><code>get_dynamic_credits_config(\n    credits_granted: int,\n    min_credits_per_request: int = 1,\n    max_credits_per_request: int = 1,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Get a dynamic credits configuration for a plan.</p> PARAMETER DESCRIPTION <code>credits_granted</code> <p>The total number of credits granted</p> <p> TYPE: <code>int</code> </p> <code>min_credits_per_request</code> <p>The minimum number of credits consumed per request (default: 1)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>max_credits_per_request</code> <p>The maximum number of credits consumed per request (default: 1)</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>PlanCreditsConfig</code> <p>A PlanCreditsConfig object configured for dynamic credits</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_dynamic_credits_config(\n    credits_granted: int,\n    min_credits_per_request: int = 1,\n    max_credits_per_request: int = 1,\n) -&gt; PlanCreditsConfig:\n    \"\"\"\n    Get a dynamic credits configuration for a plan.\n\n    Args:\n        credits_granted: The total number of credits granted\n        min_credits_per_request: The minimum number of credits consumed per request (default: 1)\n        max_credits_per_request: The maximum number of credits consumed per request (default: 1)\n\n    Returns:\n        A PlanCreditsConfig object configured for dynamic credits\n    \"\"\"\n    return PlanCreditsConfig(\n        is_redemption_amount_fixed=False,\n        redemption_type=PlanRedemptionType.ONLY_SUBSCRIBER,\n        proof_required=False,\n        duration_secs=0,\n        amount=str(credits_granted),\n        min_amount=min_credits_per_request,\n        max_amount=max_credits_per_request,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_expirable_duration_config","title":"get_expirable_duration_config","text":"<pre><code>get_expirable_duration_config(\n    duration_of_plan: int,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Get an expirable duration configuration for a plan.</p> PARAMETER DESCRIPTION <code>duration_of_plan</code> <p>The duration of the plan in seconds</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>PlanCreditsConfig</code> <p>A PlanCreditsConfig object configured for expirable duration</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_expirable_duration_config(duration_of_plan: int) -&gt; PlanCreditsConfig:\n    \"\"\"\n    Get an expirable duration configuration for a plan.\n\n    Args:\n        duration_of_plan: The duration of the plan in seconds\n\n    Returns:\n        A PlanCreditsConfig object configured for expirable duration\n    \"\"\"\n    return PlanCreditsConfig(\n        is_redemption_amount_fixed=False,\n        redemption_type=PlanRedemptionType.ONLY_SUBSCRIBER,\n        proof_required=False,\n        duration_secs=duration_of_plan,\n        amount=\"1\",\n        min_amount=1,\n        max_amount=1,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.get_non_expirable_duration_config","title":"get_non_expirable_duration_config","text":"<pre><code>get_non_expirable_duration_config() -&gt; PlanCreditsConfig\n</code></pre> <p>Get a non-expirable duration configuration for a plan.</p> RETURNS DESCRIPTION <code>PlanCreditsConfig</code> <p>A PlanCreditsConfig object configured for non-expirable duration</p> Source code in <code>payments_py/plans.py</code> <pre><code>def get_non_expirable_duration_config() -&gt; PlanCreditsConfig:\n    \"\"\"\n    Get a non-expirable duration configuration for a plan.\n\n    Returns:\n        A PlanCreditsConfig object configured for non-expirable duration\n    \"\"\"\n    return get_expirable_duration_config(0)\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.set_redemption_type","title":"set_redemption_type","text":"<pre><code>set_redemption_type(\n    credits_config: PlanCreditsConfig,\n    redemption_type: PlanRedemptionType,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Set the redemption type for a credits configuration.</p> PARAMETER DESCRIPTION <code>credits_config</code> <p>The credits configuration to modify</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> <code>redemption_type</code> <p>The new redemption type</p> <p> TYPE: <code>PlanRedemptionType</code> </p> RETURNS DESCRIPTION <code>PlanCreditsConfig</code> <p>A new PlanCreditsConfig with the updated redemption type</p> Source code in <code>payments_py/plans.py</code> <pre><code>def set_redemption_type(\n    credits_config: PlanCreditsConfig, redemption_type: PlanRedemptionType\n) -&gt; PlanCreditsConfig:\n    \"\"\"\n    Set the redemption type for a credits configuration.\n\n    Args:\n        credits_config: The credits configuration to modify\n        redemption_type: The new redemption type\n\n    Returns:\n        A new PlanCreditsConfig with the updated redemption type\n    \"\"\"\n    return PlanCreditsConfig(\n        credits_type=credits_config.credits_type,\n        redemption_type=redemption_type,\n        proof_required=credits_config.proof_required,\n        duration_secs=credits_config.duration_secs,\n        amount=credits_config.amount,\n        min_amount=credits_config.min_amount,\n        max_amount=credits_config.max_amount,\n    )\n</code></pre>"},{"location":"reference/data_models/#payments_py.plans.set_proof_required","title":"set_proof_required","text":"<pre><code>set_proof_required(\n    credits_config: PlanCreditsConfig,\n    proof_required: bool = True,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Set whether proof is required for a credits configuration.</p> PARAMETER DESCRIPTION <code>credits_config</code> <p>The credits configuration to modify</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> <code>proof_required</code> <p>Whether proof is required (default: True)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>PlanCreditsConfig</code> <p>A new PlanCreditsConfig with the updated proof requirement</p> Source code in <code>payments_py/plans.py</code> <pre><code>def set_proof_required(\n    credits_config: PlanCreditsConfig, proof_required: bool = True\n) -&gt; PlanCreditsConfig:\n    \"\"\"\n    Set whether proof is required for a credits configuration.\n\n    Args:\n        credits_config: The credits configuration to modify\n        proof_required: Whether proof is required (default: True)\n\n    Returns:\n        A new PlanCreditsConfig with the updated proof requirement\n    \"\"\"\n    return PlanCreditsConfig(\n        credits_type=credits_config.credits_type,\n        redemption_type=credits_config.redemption_type,\n        proof_required=proof_required,\n        duration_secs=credits_config.duration_secs,\n        amount=credits_config.amount,\n        min_amount=credits_config.min_amount,\n        max_amount=credits_config.max_amount,\n    )\n</code></pre>"},{"location":"reference/environments/","title":"Environments Reference","text":"<p>Environment configuration for the SDK.</p>"},{"location":"reference/environments/#environment-info","title":"Environment Info","text":""},{"location":"reference/environments/#payments_py.environments.EnvironmentInfo","title":"EnvironmentInfo  <code>dataclass</code>","text":"<pre><code>EnvironmentInfo(\n    backend: str,\n    proxy: str,\n    helicone_url: str,\n    frontend: str = None,\n)\n</code></pre> <p>Data class to store environment information.</p> ATTRIBUTE DESCRIPTION <code>frontend</code> <p>Frontend URL</p> <p> TYPE: <code>str</code> </p> <code>backend</code> <p>Backend URL</p> <p> TYPE: <code>str</code> </p> <code>proxy</code> <p>Proxy URL</p> <p> TYPE: <code>str</code> </p> <code>helicone_url</code> <p>Helicone URL</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/environments/#functions","title":"Functions","text":""},{"location":"reference/environments/#payments_py.environments.get_environment","title":"get_environment","text":"<pre><code>get_environment(name: EnvironmentName) -&gt; EnvironmentInfo\n</code></pre> <p>Get the environment configuration by name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the environment.</p> <p> TYPE: <code>EnvironmentName</code> </p> RETURNS DESCRIPTION <code>EnvironmentInfo</code> <p>The environment configuration.</p> <p> TYPE: <code>EnvironmentInfo</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the environment name is not defined.</p> Source code in <code>payments_py/environments.py</code> <pre><code>def get_environment(name: EnvironmentName) -&gt; EnvironmentInfo:\n    \"\"\"\n    Get the environment configuration by name.\n\n    Args:\n        name: The name of the environment.\n\n    Returns:\n        EnvironmentInfo: The environment configuration.\n\n    Raises:\n        ValueError: If the environment name is not defined.\n    \"\"\"\n    if name not in Environments:\n        raise ValueError(f\"Environment '{name}' is not defined.\")\n    return Environments[name]\n</code></pre>"},{"location":"reference/environments/#constants","title":"Constants","text":""},{"location":"reference/environments/#environments","title":"Environments","text":""},{"location":"reference/environments/#payments_py.environments.Environments","title":"Environments  <code>module-attribute</code>","text":"<pre><code>Environments = {\n    \"staging_sandbox\": EnvironmentInfo(\n        frontend=\"https://nevermined.dev\",\n        backend=\"https://api.sandbox.nevermined.dev\",\n        proxy=\"https://proxy.sandbox.nevermined.dev\",\n        helicone_url=\"https://helicone.nevermined.dev\",\n    ),\n    \"staging_live\": EnvironmentInfo(\n        frontend=\"https://nevermined.dev\",\n        backend=\"https://api.live.nevermined.dev\",\n        proxy=\"https://proxy.live.nevermined.dev\",\n        helicone_url=\"https://helicone.nevermined.dev\",\n    ),\n    \"sandbox\": EnvironmentInfo(\n        frontend=\"https://nevermined.app\",\n        backend=\"https://api.sandbox.nevermined.app\",\n        proxy=\"https://proxy.sandbox.nevermined.app\",\n        helicone_url=\"https://helicone.nevermined.dev\",\n    ),\n    \"live\": EnvironmentInfo(\n        frontend=\"https://nevermined.app\",\n        backend=\"https://api.live.nevermined.app\",\n        proxy=\"https://proxy.live.nevermined.app\",\n        helicone_url=\"https://helicone.nevermined.dev\",\n    ),\n    \"custom\": EnvironmentInfo(\n        frontend=getenv(\n            \"NVM_FRONTEND_URL\", \"http://localhost:3000\"\n        ),\n        backend=getenv(\n            \"NVM_BACKEND_URL\", \"http://localhost:3001\"\n        ),\n        proxy=getenv(\n            \"NVM_PROXY_URL\", \"https://localhost:443\"\n        ),\n        helicone_url=getenv(\n            \"HELICONE_URL\", \"http://localhost:8585\"\n        ),\n    ),\n}\n</code></pre>"},{"location":"reference/environments/#zeroaddress","title":"ZeroAddress","text":""},{"location":"reference/environments/#payments_py.environments.ZeroAddress","title":"ZeroAddress  <code>module-attribute</code>","text":"<pre><code>ZeroAddress = '0x0000000000000000000000000000000000000000'\n</code></pre>"},{"location":"reference/payments/","title":"Payments Class Reference","text":"<p>The main entry point for the Nevermined Payments Python SDK.</p>"},{"location":"reference/payments/#payments","title":"Payments","text":""},{"location":"reference/payments/#payments_py.payments.Payments","title":"Payments","text":"<pre><code>Payments(\n    options: PaymentOptions,\n    is_browser_instance: bool = False,\n)\n</code></pre> <p>               Bases: <code>BasePaymentsAPI</code></p> <p>Main class that interacts with the Nevermined payments API. Use <code>Payments.get_instance</code> for server-side usage.</p> <p>The library provides methods to manage AI Agents, Plans &amp; process AI Agent Requests.</p> <p>Each of these functionalities is encapsulated in its own API class: - <code>plans</code>: Manages AI Plans, including registration and ordering and retrieving plan details. - <code>agents</code>: Handles AI Agents, including registration of AI Agents and access token generation. - <code>requests</code>: Manages requests received by AI Agents, including validation and tracking. - <code>facilitator</code>: Handles X402 permission verification and settlement for AI Agents acting as facilitators.</p> <p>Initialize the Payments class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The initialization options</p> <p> TYPE: <code>PaymentOptions</code> </p> <code>is_browser_instance</code> <p>Whether this is a browser instance (default False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>payments_py/payments.py</code> <pre><code>def __init__(self, options: PaymentOptions, is_browser_instance: bool = False):\n    \"\"\"\n    Initialize the Payments class.\n\n    Args:\n        options: The initialization options\n        is_browser_instance: Whether this is a browser instance (default False)\n    \"\"\"\n    super().__init__(options)\n    self.is_browser_instance = is_browser_instance\n    self._initialize_api(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.payments.Payments.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(options: PaymentOptions) -&gt; Payments\n</code></pre> <p>Get an instance of the Payments class for server-side usage.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>Payments</code> <p>An instance of Payments</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If nvm_api_key is missing</p> Source code in <code>payments_py/payments.py</code> <pre><code>@classmethod\ndef get_instance(cls, options: PaymentOptions) -&gt; \"Payments\":\n    \"\"\"\n    Get an instance of the Payments class for server-side usage.\n\n    Args:\n        options: The options to initialize the payments class\n\n    Returns:\n        An instance of Payments\n\n    Raises:\n        PaymentsError: If nvm_api_key is missing\n    \"\"\"\n    if not options.nvm_api_key:\n        raise PaymentsError.unauthorized(\"Nevermined API Key is required\")\n    return cls(options, False)\n</code></pre>"},{"location":"reference/payments/#payments_py.payments.Payments.get_browser_instance","title":"get_browser_instance  <code>classmethod</code>","text":"<pre><code>get_browser_instance(options: PaymentOptions) -&gt; Payments\n</code></pre> <p>Get an instance of the Payments class for browser usage.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>Payments</code> <p>An instance of Payments</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If return_url is missing</p> Source code in <code>payments_py/payments.py</code> <pre><code>@classmethod\ndef get_browser_instance(cls, options: PaymentOptions) -&gt; \"Payments\":\n    \"\"\"\n    Get an instance of the Payments class for browser usage.\n\n    Args:\n        options: The options to initialize the payments class\n\n    Returns:\n        An instance of Payments\n\n    Raises:\n        PaymentsError: If return_url is missing\n    \"\"\"\n    if not options.return_url:\n        raise PaymentsError.validation(\"return_url is required\")\n    return cls(options, True)\n</code></pre>"},{"location":"reference/payments/#plans-api","title":"Plans API","text":""},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI","title":"PlansAPI","text":"<pre><code>PlansAPI(options: PaymentOptions)\n</code></pre> <p>               Bases: <code>BasePaymentsAPI</code></p> <p>The PlansAPI class provides methods to register and interact with payment plans on Nevermined.</p> <p>Initialize the PlansAPI class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def __init__(self, options: PaymentOptions):\n    \"\"\"\n    Initialize the PlansAPI class.\n\n    Args:\n        options: The options to initialize the payments class\n    \"\"\"\n    super().__init__(options)\n    self.contracts_api = ContractsAPI(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(options: PaymentOptions) -&gt; PlansAPI\n</code></pre> <p>Get a singleton instance of the PlansAPI class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>PlansAPI</code> <p>The instance of the PlansAPI class</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@classmethod\ndef get_instance(cls, options: PaymentOptions) -&gt; \"PlansAPI\":\n    \"\"\"\n    Get a singleton instance of the PlansAPI class.\n\n    Args:\n        options: The options to initialize the payments class\n\n    Returns:\n        The instance of the PlansAPI class\n    \"\"\"\n    return cls(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.register_plan","title":"register_plan","text":"<pre><code>register_plan(\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n    nonce: Optional[int] = None,\n    access_limit: Optional[\n        Literal[\"credits\", \"time\"]\n    ] = None,\n) -&gt; Dict[str, str]\n</code></pre> <p>Allows an AI Builder to create a Payment Plan on Nevermined in a flexible manner. A Nevermined Credits Plan limits access based on plan usage. With them, AI Builders control the number of requests that can be made to an agent or service. Every time a user accesses any resource associated with the Payment Plan, the usage consumes from a capped amount of credits. When the user consumes all the credits, the plan automatically expires and the user needs to top up to continue using the service.</p> PARAMETER DESCRIPTION <code>plan_metadata</code> <p>Plan metadata</p> <p> TYPE: <code>PlanMetadata</code> </p> <code>price_config</code> <p>Plan price configuration</p> <p> TYPE: <code>PlanPriceConfig</code> </p> <code>credits_config</code> <p>Plan credits configuration</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> <code>nonce</code> <p>Optional nonce for the transaction</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict[str, str]</code> <p>The unique identifier of the plan (Plan ID) of the newly created plan</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If registration fails</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def register_plan(\n    self,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n    nonce: Optional[int] = None,\n    access_limit: Optional[\n        Literal[\"credits\", \"time\"]\n    ] = None,  # 'credits' or 'time'\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Allows an AI Builder to create a Payment Plan on Nevermined in a flexible manner.\n    A Nevermined Credits Plan limits access based on plan usage.\n    With them, AI Builders control the number of requests that can be made to an agent or service.\n    Every time a user accesses any resource associated with the Payment Plan, the usage consumes from a capped amount of credits.\n    When the user consumes all the credits, the plan automatically expires and the user needs to top up to continue using the service.\n\n    Args:\n        plan_metadata: Plan metadata\n        price_config: Plan price configuration\n        credits_config: Plan credits configuration\n        nonce: Optional nonce for the transaction\n\n    Returns:\n        The unique identifier of the plan (Plan ID) of the newly created plan\n\n    Raises:\n        PaymentsError: If registration fails\n    \"\"\"\n    if access_limit and access_limit not in [\"credits\", \"time\"]:\n        raise PaymentsError.validation(\n            \"Invalid access limit\",\n            \"accessLimit must be either 'credits' or 'time'\",\n        )\n    if not access_limit:\n        access_limit = \"time\" if credits_config.duration_secs &gt; 0 else \"credits\"\n\n    if nonce is None:\n        nonce = get_random_big_int()\n\n    body = {\n        \"metadataAttributes\": self.pydantic_to_dict(plan_metadata),\n        \"priceConfig\": self.pydantic_to_dict(price_config),\n        \"creditsConfig\": self.pydantic_to_dict(credits_config),\n        \"nonce\": nonce,\n        \"isTrialPlan\": getattr(plan_metadata, \"is_trial_plan\", False),\n        \"accessLimit\": access_limit,\n    }\n\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_REGISTER_PLAN}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to register plan. {response.status_code} - {response.text}\"\n        )\n\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.register_credits_plan","title":"register_credits_plan","text":"<pre><code>register_credits_plan(\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]\n</code></pre> <p>Allows an AI Builder to create a Payment Plan on Nevermined based on Credits. A Nevermined Credits Plan limits the access by the access/usage of the Plan. With them, AI Builders control the number of requests that can be made to an agent or service. Every time a user accesses any resource associated with the Payment Plan, the usage consumes from a capped amount of credits. When the user consumes all the credits, the plan automatically expires and the user needs to top up to continue using the service.</p> PARAMETER DESCRIPTION <code>plan_metadata</code> <p>Plan metadata</p> <p> TYPE: <code>PlanMetadata</code> </p> <code>price_config</code> <p>Plan price configuration</p> <p> TYPE: <code>PlanPriceConfig</code> </p> <code>credits_config</code> <p>Plan credits configuration</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> RETURNS DESCRIPTION <code>Dict[str, str]</code> <p>The unique identifier of the plan (Plan ID) of the newly created plan</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the credits configuration is invalid</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def register_credits_plan(\n    self,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Allows an AI Builder to create a Payment Plan on Nevermined based on Credits.\n    A Nevermined Credits Plan limits the access by the access/usage of the Plan.\n    With them, AI Builders control the number of requests that can be made to an agent or service.\n    Every time a user accesses any resource associated with the Payment Plan, the usage consumes from a capped amount of credits.\n    When the user consumes all the credits, the plan automatically expires and the user needs to top up to continue using the service.\n\n    Args:\n        plan_metadata: Plan metadata\n        price_config: Plan price configuration\n        credits_config: Plan credits configuration\n\n    Returns:\n        The unique identifier of the plan (Plan ID) of the newly created plan\n\n    Raises:\n        PaymentsError: If the credits configuration is invalid\n    \"\"\"\n\n    if credits_config.min_amount &gt; credits_config.max_amount:\n        raise PaymentsError.validation(\n            \"The creditsConfig.minAmount can not be more than creditsConfig.maxAmount\"\n        )\n\n    return self.register_plan(\n        plan_metadata, price_config, credits_config, access_limit=\"credits\"\n    )\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.register_time_plan","title":"register_time_plan","text":"<pre><code>register_time_plan(\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]\n</code></pre> <p>Allows an AI Builder to create a Payment Plan on Nevermined limited by duration. A Nevermined Credits Plan limits the access by the access/usage of the Plan. With them, AI Builders control the number of requests that can be made to an agent or service. Every time a user accesses any resource associated with the Payment Plan, the usage consumes from a capped amount of credits. When the user consumes all the credits, the plan automatically expires and the user needs to top up to continue using the service.</p> PARAMETER DESCRIPTION <code>plan_metadata</code> <p>Plan metadata</p> <p> TYPE: <code>PlanMetadata</code> </p> <code>price_config</code> <p>Plan price configuration</p> <p> TYPE: <code>PlanPriceConfig</code> </p> <code>credits_config</code> <p>Plan credits configuration</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> RETURNS DESCRIPTION <code>Dict[str, str]</code> <p>The unique identifier of the plan (Plan ID) of the newly created plan</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the credits configuration is invalid</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def register_time_plan(\n    self,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Allows an AI Builder to create a Payment Plan on Nevermined limited by duration.\n    A Nevermined Credits Plan limits the access by the access/usage of the Plan.\n    With them, AI Builders control the number of requests that can be made to an agent or service.\n    Every time a user accesses any resource associated with the Payment Plan, the usage consumes from a capped amount of credits.\n    When the user consumes all the credits, the plan automatically expires and the user needs to top up to continue using the service.\n\n    Args:\n        plan_metadata: Plan metadata\n        price_config: Plan price configuration\n        credits_config: Plan credits configuration\n\n    Returns:\n        The unique identifier of the plan (Plan ID) of the newly created plan\n\n    Raises:\n        PaymentsError: If the credits configuration is invalid\n    \"\"\"\n\n    return self.register_plan(\n        plan_metadata, price_config, credits_config, access_limit=\"time\"\n    )\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.register_credits_trial_plan","title":"register_credits_trial_plan","text":"<pre><code>register_credits_trial_plan(\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]\n</code></pre> <p>Allows an AI Builder to create a Trial Payment Plan on Nevermined based on Credits. A Nevermined Trial Plan allow subscribers of that plan to test the Agents associated to it. A Trial plan is a plan that only can be purchased once by a user.</p> PARAMETER DESCRIPTION <code>plan_metadata</code> <p>Plan metadata</p> <p> TYPE: <code>PlanMetadata</code> </p> <code>price_config</code> <p>Plan price configuration</p> <p> TYPE: <code>PlanPriceConfig</code> </p> <code>credits_config</code> <p>Plan credits configuration</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> RETURNS DESCRIPTION <code>Dict[str, str]</code> <p>The unique identifier of the plan (Plan ID) of the newly created plan</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def register_credits_trial_plan(\n    self,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Allows an AI Builder to create a Trial Payment Plan on Nevermined based on Credits.\n    A Nevermined Trial Plan allow subscribers of that plan to test the Agents associated to it.\n    A Trial plan is a plan that only can be purchased once by a user.\n\n    Args:\n        plan_metadata: Plan metadata\n        price_config: Plan price configuration\n        credits_config: Plan credits configuration\n\n    Returns:\n        The unique identifier of the plan (Plan ID) of the newly created plan\n    \"\"\"\n    plan_metadata.is_trial_plan = True\n    return self.register_credits_plan(plan_metadata, price_config, credits_config)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.register_time_trial_plan","title":"register_time_trial_plan","text":"<pre><code>register_time_trial_plan(\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]\n</code></pre> <p>Allows an AI Builder to create a Trial Payment Plan on Nevermined limited by duration. A Nevermined Trial Plan allow subscribers of that plan to test the Agents associated to it. A Trial plan is a plan that only can be purchased once by a user.</p> PARAMETER DESCRIPTION <code>plan_metadata</code> <p>Plan metadata</p> <p> TYPE: <code>PlanMetadata</code> </p> <code>price_config</code> <p>Plan price configuration</p> <p> TYPE: <code>PlanPriceConfig</code> </p> <code>credits_config</code> <p>Plan credits configuration</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> RETURNS DESCRIPTION <code>Dict[str, str]</code> <p>The unique identifier of the plan (Plan ID) of the newly created plan</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def register_time_trial_plan(\n    self,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Allows an AI Builder to create a Trial Payment Plan on Nevermined limited by duration.\n    A Nevermined Trial Plan allow subscribers of that plan to test the Agents associated to it.\n    A Trial plan is a plan that only can be purchased once by a user.\n\n    Args:\n        plan_metadata: Plan metadata\n        price_config: Plan price configuration\n        credits_config: Plan credits configuration\n\n    Returns:\n        The unique identifier of the plan (Plan ID) of the newly created plan\n    \"\"\"\n    plan_metadata.is_trial_plan = True\n    return self.register_time_plan(plan_metadata, price_config, credits_config)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_plan","title":"get_plan","text":"<pre><code>get_plan(plan_id: str) -&gt; Dict[str, Any]\n</code></pre> <p>Get the metadata for a given Plan identifier.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The plan's metadata</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the plan is not found</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def get_plan(self, plan_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the metadata for a given Plan identifier.\n\n    Args:\n        plan_id: The unique identifier of the plan\n\n    Returns:\n        The plan's metadata\n\n    Raises:\n        PaymentsError: If the plan is not found\n    \"\"\"\n    url = f\"{self.environment.backend}{API_URL_GET_PLAN.format(plan_id=plan_id)}\"\n    response = requests.get(url)\n    if not response.ok:\n        raise PaymentsError.validation(\n            f\"Plan not found. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_plan_balance","title":"get_plan_balance","text":"<pre><code>get_plan_balance(\n    plan_id: str, account_address: Optional[str] = None\n) -&gt; Dict[str, Any]\n</code></pre> <p>Get the balance of a plan for a specific account.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>account_address</code> <p>The account address to check balance for (defaults to current user)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The plan balance information with properly typed fields (balance as int)</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to get plan balance</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def get_plan_balance(\n    self, plan_id: str, account_address: Optional[str] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get the balance of a plan for a specific account.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        account_address: The account address to check balance for (defaults to current user)\n\n    Returns:\n        The plan balance information with properly typed fields (balance as int)\n\n    Raises:\n        PaymentsError: If unable to get plan balance\n    \"\"\"\n\n    if not is_ethereum_address(account_address):\n        account_address = self.get_account_address()\n\n    url = f\"{self.environment.backend}{API_URL_PLAN_BALANCE.format(plan_id=plan_id, holder_address=account_address)}\"\n    response = requests.get(\n        url,\n        headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},\n    )\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to get plan balance. {response.status_code} - {response.text}\"\n        )\n\n    # Parse and validate response using Pydantic model to ensure type conversion\n    response_data = response.json()\n    return PlanBalance(**response_data)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.order_plan","title":"order_plan","text":"<pre><code>order_plan(plan_id: str) -&gt; Dict[str, bool]\n</code></pre> <p>Order a plan by its ID.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The ID of the plan to order</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, bool]</code> <p>The result of the order operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to order the plan</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def order_plan(self, plan_id: str) -&gt; Dict[str, bool]:\n    \"\"\"\n    Order a plan by its ID.\n\n    Args:\n        plan_id: The ID of the plan to order\n\n    Returns:\n        The result of the order operation\n\n    Raises:\n        PaymentsError: If unable to order the plan\n    \"\"\"\n    options = self.get_backend_http_options(\"POST\")\n    url = f\"{self.environment.backend}{API_URL_ORDER_PLAN}\".format(plan_id=plan_id)\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to order plan. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.mint_plan_credits","title":"mint_plan_credits","text":"<pre><code>mint_plan_credits(\n    plan_id: str, credits_amount: int, credits_receiver: str\n) -&gt; Dict[str, Any]\n</code></pre> <p>Mint credits for a plan.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>credits_amount</code> <p>The amount of credits to mint</p> <p> TYPE: <code>int</code> </p> <code>credits_receiver</code> <p>The address that will receive the credits</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the mint operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to mint credits</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def mint_plan_credits(\n    self, plan_id: str, credits_amount: int, credits_receiver: str\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Mint credits for a plan.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        credits_amount: The amount of credits to mint\n        credits_receiver: The address that will receive the credits\n\n    Returns:\n        The result of the mint operation\n\n    Raises:\n        PaymentsError: If unable to mint credits\n    \"\"\"\n    body = {\n        \"planId\": plan_id,\n        \"amount\": credits_amount,\n        \"creditsReceiver\": credits_receiver,\n    }\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_MINT_PLAN}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to mint credits. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.mint_plan_expirable","title":"mint_plan_expirable","text":"<pre><code>mint_plan_expirable(\n    plan_id: str,\n    credits_amount: int,\n    credits_receiver: str,\n    credits_duration: int = 0,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Mint expirable credits for a plan.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>credits_amount</code> <p>The amount of credits to mint</p> <p> TYPE: <code>int</code> </p> <code>credits_receiver</code> <p>The address that will receive the credits</p> <p> TYPE: <code>str</code> </p> <code>credits_duration</code> <p>The duration of the credits in seconds</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the mint operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to mint credits</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def mint_plan_expirable(\n    self,\n    plan_id: str,\n    credits_amount: int,\n    credits_receiver: str,\n    credits_duration: int = 0,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Mint expirable credits for a plan.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        credits_amount: The amount of credits to mint\n        credits_receiver: The address that will receive the credits\n        credits_duration: The duration of the credits in seconds\n\n    Returns:\n        The result of the mint operation\n\n    Raises:\n        PaymentsError: If unable to mint credits\n    \"\"\"\n    body = {\n        \"planId\": plan_id,\n        \"creditsAmount\": credits_amount,\n        \"creditsReceiver\": credits_receiver,\n        \"creditsDuration\": credits_duration,\n    }\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_MINT_EXPIRABLE_PLAN}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to mint expirable credits. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.burn_credits","title":"burn_credits","text":"<pre><code>burn_credits(\n    plan_id: str, credits_amount: str\n) -&gt; Dict[str, Any]\n</code></pre> <p>Burn credits from a plan.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>credits_amount</code> <p>The amount of credits to burn</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the burn operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to burn credits</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def burn_credits(self, plan_id: str, credits_amount: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Burn credits from a plan.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        credits_amount: The amount of credits to burn\n\n    Returns:\n        The result of the burn operation\n\n    Raises:\n        PaymentsError: If unable to burn credits\n    \"\"\"\n    body = {\n        \"planId\": plan_id,\n        \"creditsAmount\": credits_amount,\n    }\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_BURN_PLAN}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to burn credits. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_agents_associated_to_plan","title":"get_agents_associated_to_plan","text":"<pre><code>get_agents_associated_to_plan(\n    plan_id: str,\n    pagination: Optional[PaginationOptions] = None,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Gets the list of agents that can be accessed with a plan.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>pagination</code> <p>Optional pagination options to control the number of results returned</p> <p> TYPE: <code>Optional[PaginationOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The list of all different agents giving access to the plan</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the plan is not found</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def get_agents_associated_to_plan(\n    self, plan_id: str, pagination: Optional[PaginationOptions] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Gets the list of agents that can be accessed with a plan.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        pagination: Optional pagination options to control the number of results returned\n\n    Returns:\n        The list of all different agents giving access to the plan\n\n    Raises:\n        PaymentsError: If the plan is not found\n    \"\"\"\n    if pagination is None:\n        pagination = PaginationOptions()\n\n    url = f\"{self.environment.backend}{API_URL_GET_PLAN_AGENTS.format(plan_id=plan_id)}\"\n    params = {\n        \"page\": pagination.page,\n        \"offset\": pagination.offset,\n    }\n    response = requests.get(url, params=params)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to get agents associated to plan. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_fiat_price_config","title":"get_fiat_price_config  <code>staticmethod</code>","text":"<pre><code>get_fiat_price_config(\n    amount: int, receiver: str\n) -&gt; PlanPriceConfig\n</code></pre> <p>Build a fiat price configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_fiat_price_config(amount: int, receiver: str) -&gt; PlanPriceConfig:\n    \"\"\"Build a fiat price configuration.\"\"\"\n    return plan_utils.get_fiat_price_config(amount, receiver)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_crypto_price_config","title":"get_crypto_price_config  <code>staticmethod</code>","text":"<pre><code>get_crypto_price_config(\n    amount: int,\n    receiver: str,\n    token_address: str = \"0x0000000000000000000000000000000000000000\",\n) -&gt; PlanPriceConfig\n</code></pre> <p>Build a crypto (native/ERC20) price configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_crypto_price_config(\n    amount: int,\n    receiver: str,\n    token_address: str = \"0x0000000000000000000000000000000000000000\",\n) -&gt; PlanPriceConfig:\n    \"\"\"Build a crypto (native/ERC20) price configuration.\"\"\"\n    return plan_utils.get_crypto_price_config(amount, receiver, token_address)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_erc20_price_config","title":"get_erc20_price_config  <code>staticmethod</code>","text":"<pre><code>get_erc20_price_config(\n    amount: int, token_address: str, receiver: str\n) -&gt; PlanPriceConfig\n</code></pre> <p>Build an ERC20 price configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_erc20_price_config(\n    amount: int, token_address: str, receiver: str\n) -&gt; PlanPriceConfig:\n    \"\"\"Build an ERC20 price configuration.\"\"\"\n    return plan_utils.get_erc20_price_config(amount, token_address, receiver)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_free_price_config","title":"get_free_price_config  <code>staticmethod</code>","text":"<pre><code>get_free_price_config() -&gt; PlanPriceConfig\n</code></pre> <p>Build a free price configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_free_price_config() -&gt; PlanPriceConfig:\n    \"\"\"Build a free price configuration.\"\"\"\n    return plan_utils.get_free_price_config()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_native_token_price_config","title":"get_native_token_price_config  <code>staticmethod</code>","text":"<pre><code>get_native_token_price_config(\n    amount: int, receiver: str\n) -&gt; PlanPriceConfig\n</code></pre> <p>Build a native token price configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_native_token_price_config(amount: int, receiver: str) -&gt; PlanPriceConfig:\n    \"\"\"Build a native token price configuration.\"\"\"\n    return plan_utils.get_native_token_price_config(amount, receiver)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_expirable_duration_config","title":"get_expirable_duration_config  <code>staticmethod</code>","text":"<pre><code>get_expirable_duration_config(\n    duration_of_plan: int,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Build an expirable duration credits configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_expirable_duration_config(duration_of_plan: int) -&gt; PlanCreditsConfig:\n    \"\"\"Build an expirable duration credits configuration.\"\"\"\n    return plan_utils.get_expirable_duration_config(duration_of_plan)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_non_expirable_duration_config","title":"get_non_expirable_duration_config  <code>staticmethod</code>","text":"<pre><code>get_non_expirable_duration_config() -&gt; PlanCreditsConfig\n</code></pre> <p>Build a non-expirable duration credits configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_non_expirable_duration_config() -&gt; PlanCreditsConfig:\n    \"\"\"Build a non-expirable duration credits configuration.\"\"\"\n    return plan_utils.get_non_expirable_duration_config()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_fixed_credits_config","title":"get_fixed_credits_config  <code>staticmethod</code>","text":"<pre><code>get_fixed_credits_config(\n    credits_granted: int, credits_per_request: int = 1\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Build a fixed credits configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_fixed_credits_config(\n    credits_granted: int, credits_per_request: int = 1\n) -&gt; PlanCreditsConfig:\n    \"\"\"Build a fixed credits configuration.\"\"\"\n    return plan_utils.get_fixed_credits_config(credits_granted, credits_per_request)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_dynamic_credits_config","title":"get_dynamic_credits_config  <code>staticmethod</code>","text":"<pre><code>get_dynamic_credits_config(\n    credits_granted: int,\n    min_credits_per_request: int = 1,\n    max_credits_per_request: int = 1,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Build a dynamic credits configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_dynamic_credits_config(\n    credits_granted: int,\n    min_credits_per_request: int = 1,\n    max_credits_per_request: int = 1,\n) -&gt; PlanCreditsConfig:\n    \"\"\"Build a dynamic credits configuration.\"\"\"\n    return plan_utils.get_dynamic_credits_config(\n        credits_granted, min_credits_per_request, max_credits_per_request\n    )\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.set_redemption_type","title":"set_redemption_type  <code>staticmethod</code>","text":"<pre><code>set_redemption_type(\n    credits_config: PlanCreditsConfig,\n    redemption_type: PlanRedemptionType,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Set redemption type on a credits configuration (returns new object).</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef set_redemption_type(\n    credits_config: PlanCreditsConfig, redemption_type: PlanRedemptionType\n) -&gt; PlanCreditsConfig:\n    \"\"\"Set redemption type on a credits configuration (returns new object).\"\"\"\n    return plan_utils.set_redemption_type(credits_config, redemption_type)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.set_proof_required","title":"set_proof_required  <code>staticmethod</code>","text":"<pre><code>set_proof_required(\n    credits_config: PlanCreditsConfig,\n    proof_required: bool = True,\n) -&gt; PlanCreditsConfig\n</code></pre> <p>Set proof requirement on a credits configuration (returns new object).</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef set_proof_required(\n    credits_config: PlanCreditsConfig, proof_required: bool = True\n) -&gt; PlanCreditsConfig:\n    \"\"\"Set proof requirement on a credits configuration (returns new object).\"\"\"\n    return plan_utils.set_proof_required(credits_config, proof_required)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_pay_as_you_go_price_config","title":"get_pay_as_you_go_price_config","text":"<pre><code>get_pay_as_you_go_price_config(\n    amount: int,\n    receiver: str,\n    token_address: str = plan_utils.ZeroAddress,\n) -&gt; PlanPriceConfig\n</code></pre> <p>Build a pay-as-you-go price configuration using contract address from API.</p> <p>This method fetches the PayAsYouGoTemplate contract address from the API info endpoint and uses it to create the price configuration. The address is cached for subsequent calls.</p> PARAMETER DESCRIPTION <code>amount</code> <p>The amount per usage in the smallest unit of the token</p> <p> TYPE: <code>int</code> </p> <code>receiver</code> <p>The address that will receive the payment</p> <p> TYPE: <code>str</code> </p> <code>token_address</code> <p>The address of the token to use for payment (defaults to native token)</p> <p> TYPE: <code>str</code> DEFAULT: <code>ZeroAddress</code> </p> RETURNS DESCRIPTION <code>PlanPriceConfig</code> <p>A PlanPriceConfig object configured for pay-as-you-go payments</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to fetch contract address from API</p> <code>ValueError</code> <p>If the receiver address is not a valid Ethereum address</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def get_pay_as_you_go_price_config(\n    self,\n    amount: int,\n    receiver: str,\n    token_address: str = plan_utils.ZeroAddress,\n) -&gt; PlanPriceConfig:\n    \"\"\"\n    Build a pay-as-you-go price configuration using contract address from API.\n\n    This method fetches the PayAsYouGoTemplate contract address from the API info endpoint\n    and uses it to create the price configuration. The address is cached for subsequent calls.\n\n    Args:\n        amount: The amount per usage in the smallest unit of the token\n        receiver: The address that will receive the payment\n        token_address: The address of the token to use for payment (defaults to native token)\n\n    Returns:\n        A PlanPriceConfig object configured for pay-as-you-go payments\n\n    Raises:\n        PaymentsError: If unable to fetch contract address from API\n        ValueError: If the receiver address is not a valid Ethereum address\n    \"\"\"\n    # Get contract address from contracts API\n    template_address = self.contracts_api.contracts.pay_as_you_go_template\n\n    return get_pay_as_you_go_price_config(\n        amount, receiver, token_address, template_address=template_address\n    )\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.get_pay_as_you_go_credits_config","title":"get_pay_as_you_go_credits_config  <code>staticmethod</code>","text":"<pre><code>get_pay_as_you_go_credits_config() -&gt; PlanCreditsConfig\n</code></pre> <p>Build a pay-as-you-go credits configuration.</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>@staticmethod\ndef get_pay_as_you_go_credits_config() -&gt; PlanCreditsConfig:\n    \"\"\"Build a pay-as-you-go credits configuration.\"\"\"\n    return get_pay_as_you_go_credits_config()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.order_fiat_plan","title":"order_fiat_plan","text":"<pre><code>order_fiat_plan(plan_id: str) -&gt; Dict[str, Any]\n</code></pre> <p>Order a fiat plan using Stripe checkout.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The Stripe checkout result</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to order the fiat plan</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def order_fiat_plan(self, plan_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Order a fiat plan using Stripe checkout.\n\n    Args:\n        plan_id: The unique identifier of the plan\n\n    Returns:\n        The Stripe checkout result\n\n    Raises:\n        PaymentsError: If unable to order the fiat plan\n    \"\"\"\n    body = {\"planId\": plan_id, \"sessionType\": \"embedded\"}\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_STRIPE_CHECKOUT}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to order fiat plan. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.plans_api.PlansAPI.redeem_credits","title":"redeem_credits","text":"<pre><code>redeem_credits(\n    agent_request_id: str,\n    plan_id: str,\n    redeem_from: str,\n    credits_amount_to_redeem: str,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Redeem credits from a plan for a specific agent request.</p> PARAMETER DESCRIPTION <code>agent_request_id</code> <p>The unique identifier of the agent request</p> <p> TYPE: <code>str</code> </p> <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>redeem_from</code> <p>The address to redeem credits from</p> <p> TYPE: <code>str</code> </p> <code>credits_amount_to_redeem</code> <p>The amount of credits to redeem</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the redeem operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to redeem credits</p> Source code in <code>payments_py/api/plans_api.py</code> <pre><code>def redeem_credits(\n    self,\n    agent_request_id: str,\n    plan_id: str,\n    redeem_from: str,\n    credits_amount_to_redeem: str,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Redeem credits from a plan for a specific agent request.\n\n    Args:\n        agent_request_id: The unique identifier of the agent request\n        plan_id: The unique identifier of the plan\n        redeem_from: The address to redeem credits from\n        credits_amount_to_redeem: The amount of credits to redeem\n\n    Returns:\n        The result of the redeem operation\n\n    Raises:\n        PaymentsError: If unable to redeem credits\n    \"\"\"\n    body = {\n        \"agentRequestId\": agent_request_id,\n        \"planId\": plan_id,\n        \"redeemFrom\": redeem_from,\n        \"amount\": credits_amount_to_redeem,\n    }\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_REDEEM_PLAN}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to redeem credits. {response.status_code} - {response.text}\"\n        )\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#agents-api","title":"Agents API","text":""},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI","title":"AgentsAPI","text":"<pre><code>AgentsAPI(options: PaymentOptions)\n</code></pre> <p>               Bases: <code>BasePaymentsAPI</code></p> <p>The AgentsAPI class provides methods to register and interact with AI Agents on Nevermined.</p> Source code in <code>payments_py/api/base_payments.py</code> <pre><code>def __init__(self, options: PaymentOptions):\n    \"\"\"\n    Initialize the base payments API.\n\n    Args:\n        options: The options to initialize the payments class\n    \"\"\"\n    self.nvm_api_key = options.nvm_api_key\n    self.return_url = options.return_url or \"\"\n    self.environment = get_environment(options.environment)\n    self.environment_name = options.environment\n    self.app_id = options.app_id\n    self.version = options.version\n    self.account_address: Optional[str] = None\n    self.helicone_api_key: str = None\n    self.is_browser_instance = True\n    self._parse_nvm_api_key()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(options: PaymentOptions) -&gt; AgentsAPI\n</code></pre> <p>Get a singleton instance of the AgentsAPI class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>AgentsAPI</code> <p>The instance of the AgentsAPI class</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>@classmethod\ndef get_instance(cls, options: PaymentOptions) -&gt; \"AgentsAPI\":\n    \"\"\"\n    Get a singleton instance of the AgentsAPI class.\n\n    Args:\n        options: The options to initialize the payments class\n\n    Returns:\n        The instance of the AgentsAPI class\n    \"\"\"\n    return cls(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.register_agent","title":"register_agent","text":"<pre><code>register_agent(\n    agent_metadata: AgentMetadata,\n    agent_api: AgentAPIAttributes,\n    payment_plans: List[str],\n) -&gt; Dict[str, str]\n</code></pre> <p>Registers a new AI Agent on Nevermined. The agent must be associated to one or multiple Payment Plans. Users that are subscribers of a payment plan can query the agent. Depending on the Payment Plan and the configuration of the agent, the usage of the agent/service will consume credits. When the plan expires (because the time is over or the credits are consumed), the user needs to renew the plan to continue using the agent.</p> PARAMETER DESCRIPTION <code>agent_metadata</code> <p>Agent metadata</p> <p> TYPE: <code>AgentMetadata</code> </p> <code>agent_api</code> <p>Agent API attributes</p> <p> TYPE: <code>AgentAPIAttributes</code> </p> <code>payment_plans</code> <p>The list of payment plans giving access to the agent</p> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Dict[str, str]</code> <p>The unique identifier of the newly created agent (Agent Id)</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If registration fails</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def register_agent(\n    self,\n    agent_metadata: AgentMetadata,\n    agent_api: AgentAPIAttributes,\n    payment_plans: List[str],\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Registers a new AI Agent on Nevermined.\n    The agent must be associated to one or multiple Payment Plans. Users that are subscribers of a payment plan can query the agent.\n    Depending on the Payment Plan and the configuration of the agent, the usage of the agent/service will consume credits.\n    When the plan expires (because the time is over or the credits are consumed), the user needs to renew the plan to continue using the agent.\n\n    Args:\n        agent_metadata: Agent metadata\n        agent_api: Agent API attributes\n        payment_plans: The list of payment plans giving access to the agent\n\n    Returns:\n        The unique identifier of the newly created agent (Agent Id)\n\n    Raises:\n        PaymentsError: If registration fails\n    \"\"\"\n    body = {\n        \"metadataAttributes\": self.pydantic_to_dict(agent_metadata),\n        \"agentApiAttributes\": self.pydantic_to_dict(agent_api),\n        \"plans\": payment_plans,\n    }\n\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_REGISTER_AGENT}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Unable to register agent\", error)\n    agent_data = response.json()\n    return {\"agentId\": agent_data[\"data\"][\"agentId\"]}\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.register_agent_and_plan","title":"register_agent_and_plan","text":"<pre><code>register_agent_and_plan(\n    agent_metadata: AgentMetadata,\n    agent_api: AgentAPIAttributes,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n    access_limit: Optional[\n        Literal[\"credits\", \"time\"]\n    ] = None,\n) -&gt; Dict[str, str]\n</code></pre> <p>Registers a new AI Agent and a Payment Plan associated to this new agent. Depending on the Payment Plan and the configuration of the agent, the usage of the agent/service will consume credits. When the plan expires (because the time is over or the credits are consumed), the user needs to renew the plan to continue using the agent.</p> PARAMETER DESCRIPTION <code>agent_metadata</code> <p>Agent metadata</p> <p> TYPE: <code>AgentMetadata</code> </p> <code>agent_api</code> <p>Agent API attributes</p> <p> TYPE: <code>AgentAPIAttributes</code> </p> <code>plan_metadata</code> <p>Plan metadata</p> <p> TYPE: <code>PlanMetadata</code> </p> <code>price_config</code> <p>Plan price configuration</p> <p> TYPE: <code>PlanPriceConfig</code> </p> <code>credits_config</code> <p>Plan credits configuration</p> <p> TYPE: <code>PlanCreditsConfig</code> </p> <code>access_limit</code> <p>Optional access limit for the plan</p> <p> TYPE: <code>Optional[Literal['credits', 'time']]</code> DEFAULT: <code>None</code> </p> <p>Returns:     Dictionary containing agentId, planId, and txHash</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If registration fails</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def register_agent_and_plan(\n    self,\n    agent_metadata: AgentMetadata,\n    agent_api: AgentAPIAttributes,\n    plan_metadata: PlanMetadata,\n    price_config: PlanPriceConfig,\n    credits_config: PlanCreditsConfig,\n    access_limit: Optional[Literal[\"credits\", \"time\"]] = None,\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Registers a new AI Agent and a Payment Plan associated to this new agent.\n    Depending on the Payment Plan and the configuration of the agent, the usage of the agent/service will consume credits.\n    When the plan expires (because the time is over or the credits are consumed), the user needs to renew the plan to continue using the agent.\n\n    Args:\n        agent_metadata: Agent metadata\n        agent_api: Agent API attributes\n        plan_metadata: Plan metadata\n        price_config: Plan price configuration\n        credits_config: Plan credits configuration\n        access_limit: Optional access limit for the plan\n    Returns:\n        Dictionary containing agentId, planId, and txHash\n\n    Raises:\n        PaymentsError: If registration fails\n    \"\"\"\n    if access_limit and access_limit not in [\"credits\", \"time\"]:\n        raise PaymentsError.validation(\n            \"Invalid access limit\",\n            \"accessLimit must be either 'credits' or 'time'\",\n        )\n    if not access_limit:\n        access_limit = \"time\" if credits_config.duration_secs &gt; 0 else \"credits\"\n\n    body = {\n        \"plan\": {\n            \"metadataAttributes\": self.pydantic_to_dict(plan_metadata),\n            \"priceConfig\": self.pydantic_to_dict(price_config),\n            \"creditsConfig\": self.pydantic_to_dict(credits_config),\n            \"accessLimit\": access_limit,\n        },\n        \"agent\": {\n            \"metadataAttributes\": self.pydantic_to_dict(agent_metadata),\n            \"agentApiAttributes\": self.pydantic_to_dict(agent_api),\n        },\n    }\n\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_REGISTER_AGENTS_AND_PLAN}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Unable to register agent &amp; plan\", error)\n    result = response.json()\n\n    return {\n        \"agentId\": result[\"data\"][\"agentId\"],\n        \"planId\": result[\"data\"][\"planId\"],\n        \"txHash\": result[\"txHash\"],\n    }\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.get_agent","title":"get_agent","text":"<pre><code>get_agent(agent_id: str) -&gt; Dict[str, Any]\n</code></pre> <p>Gets the metadata for a given Agent identifier.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>The unique identifier of the agent</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The agent's metadata</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the agent is not found</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def get_agent(self, agent_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Gets the metadata for a given Agent identifier.\n\n    Args:\n        agent_id: The unique identifier of the agent\n\n    Returns:\n        The agent's metadata\n\n    Raises:\n        PaymentsError: If the agent is not found\n    \"\"\"\n    url = f\"{self.environment.backend}{API_URL_GET_AGENT.format(agent_id=agent_id)}\"\n    response = requests.get(url)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Agent not found\", error)\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.get_agent_plans","title":"get_agent_plans","text":"<pre><code>get_agent_plans(\n    agent_id: str,\n    pagination: Optional[PaginationOptions] = None,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Gets the list of plans that can be ordered to get access to an agent.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>The unique identifier of the agent</p> <p> TYPE: <code>str</code> </p> <code>pagination</code> <p>Optional pagination options to control the number of results returned</p> <p> TYPE: <code>Optional[PaginationOptions]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The list of all different plans giving access to the agent</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the agent is not found</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def get_agent_plans(\n    self, agent_id: str, pagination: Optional[PaginationOptions] = None\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Gets the list of plans that can be ordered to get access to an agent.\n\n    Args:\n        agent_id: The unique identifier of the agent\n        pagination: Optional pagination options to control the number of results returned\n\n    Returns:\n        The list of all different plans giving access to the agent\n\n    Raises:\n        PaymentsError: If the agent is not found\n    \"\"\"\n    if pagination is None:\n        pagination = PaginationOptions()\n\n    url = f\"{self.environment.backend}{API_URL_GET_AGENT_PLANS.format(agent_id=agent_id)}\"\n    params = {\n        \"page\": pagination.page,\n        \"offset\": pagination.offset,\n    }\n    response = requests.get(url, params=params)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Unable to get agent plans\", error)\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.add_plan_to_agent","title":"add_plan_to_agent","text":"<pre><code>add_plan_to_agent(\n    plan_id: str, agent_id: str\n) -&gt; Dict[str, Any]\n</code></pre> <p>Add a plan to an agent.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>agent_id</code> <p>The unique identifier of the agent</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to add plan to agent</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def add_plan_to_agent(self, plan_id: str, agent_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Add a plan to an agent.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        agent_id: The unique identifier of the agent\n\n    Returns:\n        The result of the operation\n\n    Raises:\n        PaymentsError: If unable to add plan to agent\n    \"\"\"\n    options = self.get_backend_http_options(\"POST\")\n    url = f\"{self.environment.backend}{API_URL_ADD_PLAN_AGENT.format(agent_id=agent_id, plan_id=plan_id)}\"\n\n    response = requests.post(url, **options)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Unable to add plan to agent\", error)\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.remove_plan_from_agent","title":"remove_plan_from_agent","text":"<pre><code>remove_plan_from_agent(\n    plan_id: str, agent_id: str\n) -&gt; Dict[str, Any]\n</code></pre> <p>Remove a plan from an agent.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the plan</p> <p> TYPE: <code>str</code> </p> <code>agent_id</code> <p>The unique identifier of the agent</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to remove plan from agent</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def remove_plan_from_agent(self, plan_id: str, agent_id: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Remove a plan from an agent.\n\n    Args:\n        plan_id: The unique identifier of the plan\n        agent_id: The unique identifier of the agent\n\n    Returns:\n        The result of the operation\n\n    Raises:\n        PaymentsError: If unable to remove plan from agent\n    \"\"\"\n    url = f\"{self.environment.backend}{API_URL_REMOVE_PLAN_AGENT.format(agent_id=agent_id, plan_id=plan_id)}\"\n    options = self.get_backend_http_options(\"DELETE\")\n\n    response = requests.delete(url, **options)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Unable to remove plan from agent\", error)\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.agents_api.AgentsAPI.update_agent_metadata","title":"update_agent_metadata","text":"<pre><code>update_agent_metadata(\n    agent_id: str,\n    agent_metadata: AgentMetadata,\n    agent_api: AgentAPIAttributes,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Updates the metadata and API attributes of an existing AI Agent.</p> PARAMETER DESCRIPTION <code>agent_id</code> <p>The unique identifier of the agent</p> <p> TYPE: <code>str</code> </p> <code>agent_metadata</code> <p>The new metadata attributes for the agent</p> <p> TYPE: <code>AgentMetadata</code> </p> <code>agent_api</code> <p>The new API attributes for the agent</p> <p> TYPE: <code>AgentAPIAttributes</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The result of the update operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the agent is not found or if the update fails</p> Source code in <code>payments_py/api/agents_api.py</code> <pre><code>def update_agent_metadata(\n    self,\n    agent_id: str,\n    agent_metadata: AgentMetadata,\n    agent_api: AgentAPIAttributes,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Updates the metadata and API attributes of an existing AI Agent.\n\n    Args:\n        agent_id: The unique identifier of the agent\n        agent_metadata: The new metadata attributes for the agent\n        agent_api: The new API attributes for the agent\n\n    Returns:\n        The result of the update operation\n\n    Raises:\n        PaymentsError: If the agent is not found or if the update fails\n    \"\"\"\n    body = {\n        \"metadataAttributes\": self.pydantic_to_dict(agent_metadata),\n        \"agentApiAttributes\": self.pydantic_to_dict(agent_api),\n    }\n    url = f\"{self.environment.backend}{API_URL_UPDATE_AGENT.format(agent_id=agent_id)}\"\n    options = self.get_backend_http_options(\"PUT\", body)\n    response = requests.put(url, **options)\n    if not response.ok:\n        try:\n            error = response.json()\n        except Exception:\n            error = {\"message\": response.text, \"code\": response.status_code}\n        raise PaymentsError.from_backend(\"Error updating agent\", error)\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#facilitator-api-x402","title":"Facilitator API (x402)","text":""},{"location":"reference/payments/#payments_py.x402.facilitator_api.FacilitatorAPI","title":"FacilitatorAPI","text":"<pre><code>FacilitatorAPI(options: PaymentOptions)\n</code></pre> <p>               Bases: <code>BasePaymentsAPI</code></p> <p>The FacilitatorAPI class provides methods to verify and settle AI agent permissions. It enables AI agents to act as facilitators, managing credit verification and settlement for subscribers using X402 access tokens.</p> Source code in <code>payments_py/api/base_payments.py</code> <pre><code>def __init__(self, options: PaymentOptions):\n    \"\"\"\n    Initialize the base payments API.\n\n    Args:\n        options: The options to initialize the payments class\n    \"\"\"\n    self.nvm_api_key = options.nvm_api_key\n    self.return_url = options.return_url or \"\"\n    self.environment = get_environment(options.environment)\n    self.environment_name = options.environment\n    self.app_id = options.app_id\n    self.version = options.version\n    self.account_address: Optional[str] = None\n    self.helicone_api_key: str = None\n    self.is_browser_instance = True\n    self._parse_nvm_api_key()\n</code></pre>"},{"location":"reference/payments/#payments_py.x402.facilitator_api.FacilitatorAPI.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(options: PaymentOptions) -&gt; FacilitatorAPI\n</code></pre> <p>Get a singleton instance of the FacilitatorAPI class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>FacilitatorAPI</code> <p>The instance of the FacilitatorAPI class</p> Source code in <code>payments_py/x402/facilitator_api.py</code> <pre><code>@classmethod\ndef get_instance(cls, options: PaymentOptions) -&gt; \"FacilitatorAPI\":\n    \"\"\"\n    Get a singleton instance of the FacilitatorAPI class.\n\n    Args:\n        options: The options to initialize the payments class\n\n    Returns:\n        The instance of the FacilitatorAPI class\n    \"\"\"\n    return cls(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.x402.facilitator_api.FacilitatorAPI.verify_permissions","title":"verify_permissions","text":"<pre><code>verify_permissions(\n    payment_required: X402PaymentRequired,\n    x402_access_token: str,\n    max_amount: Optional[str] = None,\n) -&gt; VerifyResponse\n</code></pre> <p>Verify if a subscriber has permission to use credits from a payment plan. This method simulates the credit usage without actually burning credits, checking if the subscriber has sufficient balance and permissions.</p> <p>The planId and subscriberAddress are extracted from the x402AccessToken.</p> PARAMETER DESCRIPTION <code>payment_required</code> <p>x402 PaymentRequired from 402 response (required, for validation)</p> <p> TYPE: <code>X402PaymentRequired</code> </p> <code>x402_access_token</code> <p>The X402 access token (contains planId, subscriberAddress, agentId)</p> <p> TYPE: <code>str</code> </p> <code>max_amount</code> <p>The maximum number of credits to verify (as string, optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>VerifyResponse</code> <p>VerifyResponse with is_valid boolean and optional error details</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If verification fails</p> Source code in <code>payments_py/x402/facilitator_api.py</code> <pre><code>def verify_permissions(\n    self,\n    payment_required: X402PaymentRequired,\n    x402_access_token: str,\n    max_amount: Optional[str] = None,\n) -&gt; VerifyResponse:\n    \"\"\"\n    Verify if a subscriber has permission to use credits from a payment plan.\n    This method simulates the credit usage without actually burning credits,\n    checking if the subscriber has sufficient balance and permissions.\n\n    The planId and subscriberAddress are extracted from the x402AccessToken.\n\n    Args:\n        payment_required: x402 PaymentRequired from 402 response (required, for validation)\n        x402_access_token: The X402 access token (contains planId, subscriberAddress, agentId)\n        max_amount: The maximum number of credits to verify (as string, optional)\n\n    Returns:\n        VerifyResponse with is_valid boolean and optional error details\n\n    Raises:\n        PaymentsError: If verification fails\n    \"\"\"\n    url = f\"{self.environment.backend}{API_URL_VERIFY_PERMISSIONS}\"\n\n    body: dict = {\n        \"paymentRequired\": payment_required.model_dump(by_alias=True),\n        \"x402AccessToken\": x402_access_token,\n    }\n\n    if max_amount is not None:\n        body[\"maxAmount\"] = max_amount\n\n    options = self.get_public_http_options(\"POST\", body)\n\n    try:\n        response = requests.post(url, **options)\n        response.raise_for_status()\n        return VerifyResponse.model_validate(response.json())\n    except requests.HTTPError as err:\n        try:\n            error_message = response.json().get(\n                \"message\", \"Permission verification failed\"\n            )\n        except Exception:\n            error_message = \"Permission verification failed\"\n        raise PaymentsError.from_backend(\n            error_message,\n            {\"code\": f\"HTTP {response.status_code}\"},\n        ) from err\n    except Exception as err:\n        if isinstance(err, PaymentsError):\n            raise\n        raise PaymentsError.from_backend(\n            \"Network error during permission verification\",\n            {\"code\": \"network_error\", \"message\": str(err)},\n        ) from err\n</code></pre>"},{"location":"reference/payments/#payments_py.x402.facilitator_api.FacilitatorAPI.settle_permissions","title":"settle_permissions","text":"<pre><code>settle_permissions(\n    payment_required: X402PaymentRequired,\n    x402_access_token: str,\n    max_amount: Optional[str] = None,\n    agent_request_id: Optional[str] = None,\n) -&gt; SettleResponse\n</code></pre> <p>Settle (burn) credits from a subscriber's payment plan. This method executes the actual credit consumption, burning the specified number of credits from the subscriber's balance. If the subscriber doesn't have enough credits, it will attempt to order more before settling.</p> <p>The planId and subscriberAddress are extracted from the x402AccessToken.</p> PARAMETER DESCRIPTION <code>payment_required</code> <p>x402 PaymentRequired from 402 response (required, for validation)</p> <p> TYPE: <code>X402PaymentRequired</code> </p> <code>x402_access_token</code> <p>The X402 access token (contains planId, subscriberAddress, agentId)</p> <p> TYPE: <code>str</code> </p> <code>max_amount</code> <p>The number of credits to burn (as string, optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>agent_request_id</code> <p>Agent request ID for observability tracking (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>SettleResponse</code> <p>SettleResponse with success boolean and transaction details</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If settlement fails</p> Source code in <code>payments_py/x402/facilitator_api.py</code> <pre><code>def settle_permissions(\n    self,\n    payment_required: X402PaymentRequired,\n    x402_access_token: str,\n    max_amount: Optional[str] = None,\n    agent_request_id: Optional[str] = None,\n) -&gt; SettleResponse:\n    \"\"\"\n    Settle (burn) credits from a subscriber's payment plan.\n    This method executes the actual credit consumption, burning the specified\n    number of credits from the subscriber's balance. If the subscriber doesn't\n    have enough credits, it will attempt to order more before settling.\n\n    The planId and subscriberAddress are extracted from the x402AccessToken.\n\n    Args:\n        payment_required: x402 PaymentRequired from 402 response (required, for validation)\n        x402_access_token: The X402 access token (contains planId, subscriberAddress, agentId)\n        max_amount: The number of credits to burn (as string, optional)\n        agent_request_id: Agent request ID for observability tracking (optional)\n\n    Returns:\n        SettleResponse with success boolean and transaction details\n\n    Raises:\n        PaymentsError: If settlement fails\n    \"\"\"\n    url = f\"{self.environment.backend}{API_URL_SETTLE_PERMISSIONS}\"\n\n    body: dict = {\n        \"paymentRequired\": payment_required.model_dump(by_alias=True),\n        \"x402AccessToken\": x402_access_token,\n    }\n\n    if max_amount is not None:\n        body[\"maxAmount\"] = max_amount\n\n    if agent_request_id is not None:\n        body[\"agentRequestId\"] = agent_request_id\n\n    options = self.get_public_http_options(\"POST\", body)\n\n    try:\n        response = requests.post(url, **options)\n        response.raise_for_status()\n        return SettleResponse.model_validate(response.json())\n    except requests.HTTPError as err:\n        try:\n            error_message = response.json().get(\n                \"message\", \"Permission settlement failed\"\n            )\n        except Exception:\n            error_message = \"Permission settlement failed\"\n        raise PaymentsError.from_backend(\n            error_message,\n            {\"code\": f\"HTTP {response.status_code}\"},\n        ) from err\n    except Exception as err:\n        if isinstance(err, PaymentsError):\n            raise\n        raise PaymentsError.from_backend(\n            \"Network error during permission settlement\",\n            {\"code\": \"network_error\", \"message\": str(err)},\n        ) from err\n</code></pre>"},{"location":"reference/payments/#x402-token-api","title":"X402 Token API","text":""},{"location":"reference/payments/#payments_py.x402.token.X402TokenAPI","title":"X402TokenAPI","text":"<pre><code>X402TokenAPI(options: PaymentOptions)\n</code></pre> <p>               Bases: <code>BasePaymentsAPI</code></p> <p>X402 Token API for generating access tokens.</p> <p>Handles X402 access token generation for subscribers to authorize payment operations with AI agents.</p> Source code in <code>payments_py/api/base_payments.py</code> <pre><code>def __init__(self, options: PaymentOptions):\n    \"\"\"\n    Initialize the base payments API.\n\n    Args:\n        options: The options to initialize the payments class\n    \"\"\"\n    self.nvm_api_key = options.nvm_api_key\n    self.return_url = options.return_url or \"\"\n    self.environment = get_environment(options.environment)\n    self.environment_name = options.environment\n    self.app_id = options.app_id\n    self.version = options.version\n    self.account_address: Optional[str] = None\n    self.helicone_api_key: str = None\n    self.is_browser_instance = True\n    self._parse_nvm_api_key()\n</code></pre>"},{"location":"reference/payments/#payments_py.x402.token.X402TokenAPI.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(options: PaymentOptions) -&gt; X402TokenAPI\n</code></pre> <p>Get a singleton instance of the X402TokenAPI class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the API</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>X402TokenAPI</code> <p>The instance of the X402TokenAPI class</p> Source code in <code>payments_py/x402/token.py</code> <pre><code>@classmethod\ndef get_instance(cls, options: PaymentOptions) -&gt; \"X402TokenAPI\":\n    \"\"\"\n    Get a singleton instance of the X402TokenAPI class.\n\n    Args:\n        options: The options to initialize the API\n\n    Returns:\n        The instance of the X402TokenAPI class\n    \"\"\"\n    return cls(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.x402.token.X402TokenAPI.get_x402_access_token","title":"get_x402_access_token","text":"<pre><code>get_x402_access_token(\n    plan_id: str,\n    agent_id: Optional[str] = None,\n    redemption_limit: Optional[int] = None,\n    order_limit: Optional[str] = None,\n    expiration: Optional[str] = None,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Create a permission and get an X402 access token for the given plan.</p> <p>This token allows the agent to verify and settle permissions on behalf of the subscriber. The token contains cryptographically signed session keys that delegate specific permissions (order, burn) to the agent.</p> PARAMETER DESCRIPTION <code>plan_id</code> <p>The unique identifier of the payment plan</p> <p> TYPE: <code>str</code> </p> <code>agent_id</code> <p>The unique identifier of the AI agent (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>redemption_limit</code> <p>Maximum number of interactions/redemptions allowed (optional)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>order_limit</code> <p>Maximum spend limit in token units (wei) for ordering (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>expiration</code> <p>Expiration date in ISO 8601 format, e.g. \"2025-02-01T10:00:00Z\" (optional)</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A dictionary containing: - accessToken: The X402 access token string</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If the request fails</p> Example <pre><code>from payments_py import Payments, PaymentOptions\nfrom payments_py.x402 import X402TokenAPI\n\npayments = Payments.get_instance(\n    PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n)\n\ntoken_api = X402TokenAPI.get_instance(payments.options)\nresult = token_api.get_x402_access_token(plan_id=\"123\", agent_id=\"456\")\ntoken = result[\"accessToken\"]\n</code></pre> Source code in <code>payments_py/x402/token.py</code> <pre><code>def get_x402_access_token(\n    self,\n    plan_id: str,\n    agent_id: Optional[str] = None,\n    redemption_limit: Optional[int] = None,\n    order_limit: Optional[str] = None,\n    expiration: Optional[str] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Create a permission and get an X402 access token for the given plan.\n\n    This token allows the agent to verify and settle permissions on behalf\n    of the subscriber. The token contains cryptographically signed session keys\n    that delegate specific permissions (order, burn) to the agent.\n\n    Args:\n        plan_id: The unique identifier of the payment plan\n        agent_id: The unique identifier of the AI agent (optional)\n        redemption_limit: Maximum number of interactions/redemptions allowed (optional)\n        order_limit: Maximum spend limit in token units (wei) for ordering (optional)\n        expiration: Expiration date in ISO 8601 format, e.g. \"2025-02-01T10:00:00Z\" (optional)\n\n    Returns:\n        A dictionary containing:\n            - accessToken: The X402 access token string\n\n    Raises:\n        PaymentsError: If the request fails\n\n    Example:\n        ```python\n        from payments_py import Payments, PaymentOptions\n        from payments_py.x402 import X402TokenAPI\n\n        payments = Payments.get_instance(\n            PaymentOptions(nvm_api_key=\"nvm:subscriber-key\", environment=\"sandbox\")\n        )\n\n        token_api = X402TokenAPI.get_instance(payments.options)\n        result = token_api.get_x402_access_token(plan_id=\"123\", agent_id=\"456\")\n        token = result[\"accessToken\"]\n        ```\n    \"\"\"\n    url = f\"{self.environment.backend}{API_URL_CREATE_PERMISSION}\"\n\n    # Build x402-aligned request body\n    extra: Dict[str, Any] = {}\n    if agent_id is not None:\n        extra[\"agentId\"] = agent_id\n\n    body: Dict[str, Any] = {\n        \"accepted\": {\n            \"scheme\": \"nvm:erc4337\",\n            \"network\": \"eip155:84532\",\n            \"planId\": plan_id,\n            \"extra\": extra,\n        },\n    }\n\n    # Add session key config if any options are provided\n    session_key_config: Dict[str, Any] = {}\n    if redemption_limit is not None:\n        session_key_config[\"redemptionLimit\"] = redemption_limit\n    if order_limit is not None:\n        session_key_config[\"orderLimit\"] = order_limit\n    if expiration is not None:\n        session_key_config[\"expiration\"] = expiration\n    if session_key_config:\n        body[\"sessionKeyConfig\"] = session_key_config\n\n    options = self.get_backend_http_options(\"POST\", body)\n\n    try:\n        response = requests.post(url, **options)\n        response.raise_for_status()\n        return response.json()\n    except requests.HTTPError as err:\n        try:\n            error_message = response.json().get(\n                \"message\", \"Failed to create X402 permission\"\n            )\n        except Exception:\n            error_message = \"Failed to create X402 permission\"\n        raise PaymentsError.internal(\n            f\"{error_message} (HTTP {response.status_code})\"\n        ) from err\n    except Exception as err:\n        raise PaymentsError.internal(\n            f\"Network error while creating X402 permission: {str(err)}\"\n        ) from err\n</code></pre>"},{"location":"reference/payments/#requests-api","title":"Requests API","text":""},{"location":"reference/payments/#payments_py.api.requests_api.AgentRequestsAPI","title":"AgentRequestsAPI","text":"<pre><code>AgentRequestsAPI(options: PaymentOptions)\n</code></pre> <p>               Bases: <code>BasePaymentsAPI</code></p> <p>The AgentRequestsAPI class provides methods to manage the requests received by AI Agents integrated with Nevermined.</p> <p>Note: For request validation and credit settlement, use the x402 API instead: - payments.facilitator.verify_permissions() - to verify token and permissions - payments.facilitator.settle_permissions() - to burn credits</p> Source code in <code>payments_py/api/base_payments.py</code> <pre><code>def __init__(self, options: PaymentOptions):\n    \"\"\"\n    Initialize the base payments API.\n\n    Args:\n        options: The options to initialize the payments class\n    \"\"\"\n    self.nvm_api_key = options.nvm_api_key\n    self.return_url = options.return_url or \"\"\n    self.environment = get_environment(options.environment)\n    self.environment_name = options.environment\n    self.app_id = options.app_id\n    self.version = options.version\n    self.account_address: Optional[str] = None\n    self.helicone_api_key: str = None\n    self.is_browser_instance = True\n    self._parse_nvm_api_key()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.requests_api.AgentRequestsAPI.get_instance","title":"get_instance  <code>classmethod</code>","text":"<pre><code>get_instance(options: PaymentOptions) -&gt; AgentRequestsAPI\n</code></pre> <p>Get a singleton instance of the AgentRequestsAPI class.</p> PARAMETER DESCRIPTION <code>options</code> <p>The options to initialize the payments class</p> <p> TYPE: <code>PaymentOptions</code> </p> RETURNS DESCRIPTION <code>AgentRequestsAPI</code> <p>The instance of the AgentRequestsAPI class</p> Source code in <code>payments_py/api/requests_api.py</code> <pre><code>@classmethod\ndef get_instance(cls, options: PaymentOptions) -&gt; \"AgentRequestsAPI\":\n    \"\"\"\n    Get a singleton instance of the AgentRequestsAPI class.\n\n    Args:\n        options: The options to initialize the payments class\n\n    Returns:\n        The instance of the AgentRequestsAPI class\n    \"\"\"\n    return cls(options)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.requests_api.AgentRequestsAPI.track_agent_sub_task","title":"track_agent_sub_task","text":"<pre><code>track_agent_sub_task(\n    track_agent_sub_task: TrackAgentSubTaskDto,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Tracks an agent sub task.</p> <p>This method is used by agent owners to track agent sub tasks for agent tasks. It records information about credit redemption, categorization tags, and processing descriptions.</p> PARAMETER DESCRIPTION <code>track_agent_sub_task</code> <p>The agent sub task data to track</p> <p> TYPE: <code>TrackAgentSubTaskDto</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A promise that resolves to the result of the operation</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to track the agent sub task</p> Source code in <code>payments_py/api/requests_api.py</code> <pre><code>def track_agent_sub_task(\n    self, track_agent_sub_task: TrackAgentSubTaskDto\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Tracks an agent sub task.\n\n    This method is used by agent owners to track agent sub tasks for agent tasks.\n    It records information about credit redemption, categorization tags, and processing descriptions.\n\n    Args:\n        track_agent_sub_task: The agent sub task data to track\n\n    Returns:\n        A promise that resolves to the result of the operation\n\n    Raises:\n        PaymentsError: If unable to track the agent sub task\n    \"\"\"\n    body = {\n        \"agentRequestId\": track_agent_sub_task.agent_request_id,\n        \"creditsToRedeem\": track_agent_sub_task.credits_to_redeem or 0,\n        \"tag\": track_agent_sub_task.tag,\n        \"description\": track_agent_sub_task.description,\n        \"status\": (\n            track_agent_sub_task.status.value\n            if track_agent_sub_task.status\n            else None\n        ),\n    }\n\n    options = self.get_backend_http_options(\"POST\", body)\n    url = f\"{self.environment.backend}{API_URL_TRACK_AGENT_SUB_TASK}\"\n    response = requests.post(url, **options)\n\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to track agent sub task. {response.status_code} - {response.text}\"\n        )\n\n    return response.json()\n</code></pre>"},{"location":"reference/payments/#payments_py.api.requests_api.AgentRequestsAPI.start_simulation_request","title":"start_simulation_request","text":"<pre><code>start_simulation_request(\n    price_per_credit: float = 0.01,\n    batch: bool = False,\n    agent_name: str = None,\n    plan_name: str = None,\n) -&gt; StartAgentRequest\n</code></pre> <p>This method simulates an agent request.</p> PARAMETER DESCRIPTION <code>price_per_credit</code> <p>The price per credit in USD</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> <code>batch</code> <p>Whether the request is a batch request</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>agent_name</code> <p>The name of the agent</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>plan_name</code> <p>The name of the plan</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>StartAgentRequest</code> <p>The information about the simulation of the request</p> Source code in <code>payments_py/api/requests_api.py</code> <pre><code>def start_simulation_request(\n    self,\n    price_per_credit: float = 0.01,\n    batch: bool = False,\n    agent_name: str = None,\n    plan_name: str = None,\n) -&gt; StartAgentRequest:\n    \"\"\"\n    This method simulates an agent request.\n\n    Args:\n        price_per_credit: The price per credit in USD\n        batch: Whether the request is a batch request\n        agent_name: The name of the agent\n        plan_name: The name of the plan\n\n    Returns:\n        The information about the simulation of the request\n    \"\"\"\n\n    body = {\n        \"pricePerCredit\": price_per_credit,\n        \"batch\": batch,\n    }\n    if agent_name is not None:\n        body[\"agentName\"] = agent_name\n    if plan_name is not None:\n        body[\"planName\"] = plan_name\n    options = self.get_backend_http_options(\"POST\", body)\n    url = urljoin(self.environment.backend, API_URL_SIMULATE_AGENT_REQUEST)\n    response = requests.post(url, **options)\n\n    if not response.ok:\n        raise PaymentsError.internal(\n            f\"Unable to start simulation request. {response.status_code} - {response.text}\"\n        )\n\n    response_data = response.json()\n    return StartAgentRequest(**response_data)\n</code></pre>"},{"location":"reference/payments/#payments_py.api.requests_api.AgentRequestsAPI.finish_simulation_request","title":"finish_simulation_request","text":"<pre><code>finish_simulation_request(\n    agent_request_id: str,\n    margin_percent: float = 0.2,\n    batch: bool = False,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Simulates the redemption of credits for an agent request.</p> PARAMETER DESCRIPTION <code>agent_request_id</code> <p>The unique identifier of the agent request.</p> <p> TYPE: <code>str</code> </p> <code>margin_percent</code> <p>The margin percentage to apply. Defaults to 0.2.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.2</code> </p> <code>batch</code> <p>Whether the request is a batch request. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A dictionary containing the result of the simulation, including the credits to redeem and the success status.</p> RAISES DESCRIPTION <code>PaymentsError</code> <p>If unable to finish the simulation request.</p> Source code in <code>payments_py/api/requests_api.py</code> <pre><code>def finish_simulation_request(\n    self, agent_request_id: str, margin_percent: float = 0.2, batch: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Simulates the redemption of credits for an agent request.\n\n    Args:\n        agent_request_id: The unique identifier of the agent request.\n        margin_percent: The margin percentage to apply. Defaults to 0.2.\n        batch: Whether the request is a batch request. Defaults to False.\n\n    Returns:\n        A dictionary containing the result of the simulation, including the credits to redeem and the success status.\n\n    Raises:\n        PaymentsError: If unable to finish the simulation request.\n    \"\"\"\n\n    body = {\n        \"agentRequestId\": agent_request_id,\n        \"marginPercent\": margin_percent,\n        \"batch\": batch,\n    }\n    options = self.get_backend_http_options(\"POST\", body)\n    url = urljoin(self.environment.backend, API_URL_SIMULATE_REDEEM_AGENT_REQUEST)\n\n    # Since this method is usually called immediately after the llm call\n    # the request might not be immediately available on helicone, so we need to retry.\n    max_retries = 3\n    last_error = None\n\n    for attempt in range(max_retries):\n        try:\n            response = requests.post(url, **options)\n            if not response.ok:\n                last_error = PaymentsError.internal(\n                    f\"Unable to finish simulation request. {response.status_code} - {response.text}\"\n                )\n                if attempt &lt; max_retries - 1:\n                    time.sleep(1)\n                    continue\n                raise last_error\n            return response.json()\n        except requests.exceptions.RequestException as e:\n            last_error = PaymentsError.internal(\n                f\"Unable to finish simulation request. Request failed: {str(e)}\"\n            )\n            if attempt &lt; max_retries - 1:\n                time.sleep(1)\n                continue\n            raise last_error\n</code></pre>"}]}